# Commands

Commands are the core building blocks of your CLI. They define what actions users can perform.

## Basic Command

A command requires at minimum a `name` and an `execute` function:

```typescript
cli.addCommand({
    name: "hello",
    execute: ({ logger }) => {
        logger.info("Hello, world!");
    },
});
```

## Command Properties

### Name

The command name is used to invoke the command:

```typescript
cli.addCommand({
    name: "build", // Command invoked as: cli build
    execute: () => {},
});
```

### Description

A short description displayed in help output:

```typescript
cli.addCommand({
    name: "build",
    description: "Build the project for production",
    execute: () => {},
});
```

### Aliases

Provide alternative names for your command:

```typescript
cli.addCommand({
    name: "build",
    alias: "b", // Can use: cli b
    // or multiple aliases:
    // alias: ["b", "compile"],
    execute: () => {},
});
```

### Hidden Commands

Hide commands from help output but still allow execution:

```typescript
cli.addCommand({
    name: "internal",
    hidden: true, // Won't appear in help
    execute: () => {},
});
```

### Grouped Commands

Organize commands into groups for better help organization:

```typescript
cli.addCommand({
    name: "build",
    group: "Build", // Groups commands in help output
    execute: () => {},
});

cli.addCommand({
    name: "test",
    group: "Build",
    execute: () => {},
});
```

### Examples

Provide usage examples for your command:

```typescript
cli.addCommand({
    name: "deploy",
    examples: ["deploy --env production", "deploy --env staging --dry-run"],
    execute: () => {},
});
```

## Command Execution

The `execute` function receives a `toolbox` object with all available resources:

```typescript
cli.addCommand({
    name: "example",
    execute: ({
        argument, // Positional arguments
        options, // Parsed options
        logger, // Logger instance
        runtime, // CLI runtime (for calling other commands)
        command, // Command definition
        commandName, // Command name
        argv, // Original argv
    }) => {
        // Your command logic
    },
});
```

### Async Commands

Commands can be async:

```typescript
cli.addCommand({
    name: "fetch",
    execute: async ({ logger }) => {
        const data = await fetch("https://api.example.com/data");
        logger.info("Data fetched!");
    },
});
```

## Positional Arguments

Define positional arguments using the `argument` property:

```typescript
cli.addCommand({
    name: "greet",
    argument: {
        name: "name",
        type: String,
        description: "Name to greet",
        defaultValue: "World",
    },
    execute: ({ argument }) => {
        const name = argument[0]; // Access first argument
        console.log(`Hello, ${name}!`);
    },
});
```

Usage:

```bash
cli greet Alice  # argument[0] = "Alice"
cli greet        # argument[0] = "World" (default)
```

### Multiple Arguments

Arguments accept multiple values by default:

```typescript
cli.addCommand({
    name: "copy",
    argument: {
        name: "files",
        type: String,
        description: "Files to copy",
    },
    execute: ({ argument }) => {
        // argument is an array of all provided values
        argument.forEach((file) => {
            console.log(`Copying ${file}...`);
        });
    },
});
```

Usage:

```bash
cli copy file1.txt file2.txt file3.txt
# argument = ["file1.txt", "file2.txt", "file3.txt"]
```

## Options

Commands can accept options (flags):

```typescript
cli.addCommand({
    name: "build",
    options: [
        {
            name: "production",
            type: Boolean,
            description: "Build for production",
        },
        {
            name: "output",
            alias: "o",
            type: String,
            description: "Output directory",
        },
    ],
    execute: ({ options }) => {
        if (options.production) {
            console.log("Building for production...");
        }
        console.log(`Output: ${options.output || "dist"}`);
    },
});
```

Usage:

```bash
cli build --production --output build
cli build -o build --production
```

See the [Options Guide](/docs/cerebro/guides/options) for detailed option configuration.

## Calling Other Commands

Commands can call other commands programmatically:

```typescript
cli.addCommand({
    name: "deploy",
    execute: async ({ runtime, logger }) => {
        logger.info("Building...");
        await runtime.runCommand("build", {
            argv: ["--production"],
        });

        logger.info("Testing...");
        await runtime.runCommand("test");

        logger.info("Deploying...");
    },
});
```

The `runCommand` method allows you to:

- Pass arguments via `argv` array
- Merge additional options
- Get return values from commands

```typescript
const result = await runtime.runCommand("build", {
    argv: ["--production"],
    customOption: "value",
});
```

## Error Handling

Commands can throw errors which are caught by Cerebro's error handling:

```typescript
cli.addCommand({
    name: "process",
    execute: ({ options }) => {
        if (!options.file) {
            throw new Error("File option is required");
        }
        // Process file...
    },
});
```

Errors are automatically handled and displayed to the user. See [Plugins Guide](/docs/cerebro/guides/plugins) for custom error handling.

## Complete Example

```typescript
cli.addCommand({
    name: "deploy",
    alias: "d",
    description: "Deploy the application",
    group: "Deployment",
    examples: ["deploy --env production", "deploy --env staging --dry-run"],
    argument: {
        name: "target",
        type: String,
        description: "Deployment target",
        defaultValue: "production",
    },
    options: [
        {
            name: "env",
            alias: "e",
            type: String,
            description: "Environment",
            required: true,
        },
        {
            name: "dry-run",
            type: Boolean,
            description: "Perform a dry run",
        },
    ],
    execute: async ({ argument, options, logger, runtime }) => {
        const target = argument[0];

        logger.info(`Deploying to ${target} environment...`);

        if (options.dryRun) {
            logger.info("Dry run mode - no changes will be made");
            return;
        }

        // Build first
        await runtime.runCommand("build", { argv: ["--production"] });

        // Deploy
        logger.info("Deployment complete!");
    },
});
```
