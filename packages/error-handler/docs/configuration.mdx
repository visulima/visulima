---
title: Configuration
description: Comprehensive guide to configuring error-handler for your specific needs
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

Comprehensive guide to configuring `@visulima/error-handler` for your specific needs.

## Common Options

These options are available for both HTTP and Fetch handlers.

### showTrace

Controls whether stack traces and detailed error information are displayed.

```typescript
{
    showTrace: boolean; // default: true
}
```

<Tabs items={['Development', 'Production']}>
  <Tab value="Development">
    **Development** (`showTrace: true`):
    - Full stack traces with file paths and line numbers
    - Code frames showing the error location
    - All error properties
    - Cause chain visualization
    - Source map support

    ```typescript
    const handler = await httpHandler(error, {
        showTrace: true,
    });
    ```
  </Tab>

  <Tab value="Production">
    **Production** (`showTrace: false`):
    - Generic error messages
    - Status code only
    - No stack traces
    - No file paths
    - No sensitive information

    ```typescript
    const handler = await httpHandler(error, {
        showTrace: false,
    });
    ```
  </Tab>
</Tabs>

<Callout type="warn">
  Never set `showTrace: true` in production as it can expose sensitive information about your application structure.
</Callout>

### extraHandlers

Add custom error handlers for specific content types using regex matching on the `Accept` header.

```typescript
{
    extraHandlers: Array<{
        regex: RegExp;
        handler: ErrorHandler;
    }>;
}
```

<Tabs items={['YAML', 'CSV', 'Multiple']}>
  <Tab value="YAML">
    ```typescript title="yaml-handler.ts"
    const handler = await httpHandler(error, {
        extraHandlers: [
            {
                regex: /application\/yaml/,
                handler: (error, req, res) => {
                    res.setHeader("Content-Type", "application/yaml");
                    res.statusCode = 500;
                    res.end(`error:\n  message: ${error.message}\n  code: 500`);
                },
            },
        ],
    });
    ```
  </Tab>

  <Tab value="CSV">
    ```typescript title="csv-handler.ts"
    const handler = await httpHandler(error, {
        extraHandlers: [
            {
                regex: /text\/csv/,
                handler: (error, req, res) => {
                    res.setHeader("Content-Type", "text/csv");
                    res.statusCode = 500;
                    res.end(`"Error","Message"\n"500","${error.message}"`);
                },
            },
        ],
    });
    ```
  </Tab>

  <Tab value="Multiple">
    ```typescript title="multiple-handlers.ts"
    const handler = await httpHandler(error, {
        extraHandlers: [
            {
                regex: /application\/yaml/,
                handler: (error, req, res) => {
                    res.setHeader("Content-Type", "application/yaml");
                    res.end(`error:\n  message: ${error.message}`);
                },
            },
            {
                regex: /text\/csv/,
                handler: (error, req, res) => {
                    res.setHeader("Content-Type", "text/csv");
                    res.end(`"Error","Message"\n"500","${error.message}"`);
                },
            },
        ],
    });
    ```
  </Tab>
</Tabs>

### errorPage

Custom HTML error page as a string or function.

```typescript
{
    errorPage?: 
        | string 
        | ((params: ErrorPageParams) => string | Promise<string>);
}
```

<Tabs items={['String', 'Function', 'Async Function']}>
  <Tab value="String">
    ```typescript title="error-page-string.ts"
    const handler = await httpHandler(error, {
        errorPage: `
            <!DOCTYPE html>
            <html>
            <head><title>Error</title></head>
            <body><h1>Something went wrong</h1></body>
            </html>
        `,
    });
    ```
  </Tab>

  <Tab value="Function">
    ```typescript title="error-page-function.ts"
    const handler = await httpHandler(error, {
        errorPage: ({ error, statusCode, reasonPhrase }) => `
            <!DOCTYPE html>
            <html>
            <head>
                <title>Error ${statusCode}</title>
                <style>
                    body { font-family: sans-serif; padding: 40px; }
                    .container { max-width: 600px; margin: 0 auto; }
                    .error-code { font-size: 72px; color: #dc3545; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="error-code">${statusCode}</div>
                    <h1>${reasonPhrase}</h1>
                    <p>${error.message}</p>
                </div>
            </body>
            </html>
        `,
    });
    ```
  </Tab>

  <Tab value="Async Function">
    ```typescript title="error-page-async.ts"
    const handler = await httpHandler(error, {
        errorPage: async ({ error, statusCode, request }) => {
            const template = await fs.readFile("./error-template.html", "utf-8");
            
            return template
                .replace("{{statusCode}}", String(statusCode))
                .replace("{{message}}", error.message)
                .replace("{{url}}", request.url || "");
        },
    });
    ```
  </Tab>
</Tabs>

<Accordions>
  <Accordion title="ErrorPageParams Interface">
    ```typescript
    interface ErrorPageParams {
        error: Error;
        request: IncomingMessage;
        response: ServerResponse;
        reasonPhrase: string; // e.g., "Internal Server Error"
        statusCode: number;   // e.g., 500
    }
    ```
  </Accordion>
</Accordions>

### cspNonce

Content Security Policy nonce for inline styles in HTML error pages.

```typescript
{
    cspNonce?: string;
}
```

```typescript title="csp-nonce.ts"
import crypto from "node:crypto";

// Generate nonce for each request
const nonce = crypto.randomBytes(16).toString("base64");

// Set CSP header
res.setHeader(
    "Content-Security-Policy",
    `default-src 'self'; style-src 'self' 'nonce-${nonce}'`
);

// Pass to error handler
const handler = await httpHandler(error, {
    cspNonce: nonce,
});
```

<Callout type="info">
  The nonce will be automatically added to all `<style>` tags in the HTML error page.
</Callout>

### onError

Callback function for custom error logging or processing.

```typescript
{
    onError?: (error: Error, request: Request, response: Response) => void | Promise<void>;
}
```

<Tabs items={['Logging', 'External Service', 'Custom Headers']}>
  <Tab value="Logging">
    ```typescript title="on-error-logging.ts"
    const handler = await httpHandler(error, {
        onError: async (error, request, response) => {
            console.error({
                timestamp: new Date().toISOString(),
                method: request.method,
                url: request.url,
                error: error.message,
                stack: error.stack,
            });
        },
    });
    ```
  </Tab>

  <Tab value="External Service">
    ```typescript title="on-error-service.ts"
    const handler = await httpHandler(error, {
        onError: async (error, request, response) => {
            await logService.error({
                error: error.message,
                stack: error.stack,
                request: {
                    method: request.method,
                    url: request.url,
                    headers: request.headers,
                },
            });
        },
    });
    ```
  </Tab>

  <Tab value="Custom Headers">
    ```typescript title="on-error-headers.ts"
    const handler = await httpHandler(error, {
        onError: async (error, request, response) => {
            response.setHeader("X-Error-ID", generateErrorId());
            response.setHeader("X-Error-Timestamp", new Date().toISOString());
        },
    });
    ```
  </Tab>
</Tabs>

## HTTP Handler Options

Complete options type for Node.js HTTP handlers:

```typescript
interface HttpHandlerOptions {
    showTrace?: boolean;
    extraHandlers?: Array<{
        regex: RegExp;
        handler: (
            error: Error,
            request: IncomingMessage,
            response: ServerResponse
        ) => void | Promise<void>;
    }>;
    errorPage?: string | ((params: ErrorPageParams) => string | Promise<string>);
    cspNonce?: string;
    onError?: (
        error: Error,
        request: IncomingMessage,
        response: ServerResponse
    ) => void | Promise<void>;
}
```

## Fetch Handler Options

Complete options type for Fetch-based handlers:

```typescript
interface FetchHandlerOptions {
    showTrace?: boolean;
    extraHandlers?: Array<{
        regex: RegExp;
        handler: (
            error: Error,
            request: Request
        ) => Response | Promise<Response>;
    }>;
    errorPage?: string | ((params: FetchErrorPageParams) => string | Promise<string>);
    cspNonce?: string;
    onError?: (
        error: Error,
        request: Request,
        response: Response
    ) => void | Promise<void>;
}
```

```typescript title="fetch-handler-example.ts"
const handler = await fetchHandler(error, {
    showTrace: false,
    extraHandlers: [
        {
            regex: /application\/yaml/,
            handler: (error, request) => {
                return new Response(
                    `error:\n  message: ${error.message}`,
                    {
                        status: 500,
                        headers: { "Content-Type": "application/yaml" },
                    }
                );
            },
        },
    ],
    onError: async (error, request) => {
        console.error(`Error on ${request.url}:`, error);
    },
});
```

## CLI Handler Options

Configuration options for CLI error handlers:

```typescript
interface CliHandlerOptions {
    // Display short paths instead of absolute paths
    displayShortPath?: boolean; // default: false
    
    // Number of lines to show before the error line
    frameContextLines?: number; // default: 2
    
    // Custom color configuration
    color?: {
        boxen?: {
            borderColor?: (text: string) => string;
            headerTextColor?: (text: string) => string;
            textColor?: (text: string) => string;
        };
    };
}
```

### displayShortPath

Show relative paths instead of absolute paths in error output.

<Tabs items={['Absolute Paths', 'Short Paths']}>
  <Tab value="Absolute Paths">
    ```typescript
    await cliHandler(error, {
        displayShortPath: false,
    });
    ```

    **Output:**
    ```
    /home/user/projects/myapp/src/utils/config.ts:42:10
    ```
  </Tab>

  <Tab value="Short Paths">
    ```typescript
    await cliHandler(error, {
        displayShortPath: true,
    });
    ```

    **Output:**
    ```
    src/utils/config.ts:42:10
    ```
  </Tab>
</Tabs>

### frameContextLines

Number of context lines to show before and after the error line.

```typescript title="frame-context.ts"
await cliHandler(error, {
    frameContextLines: 3, // Show 3 lines before and after
});
```

### color

Custom color functions for the error output box.

```typescript title="cli-colors.ts"
await cliHandler(error, {
    color: {
        boxen: {
            // Red border
            borderColor: (text) => `\x1b[31m${text}\x1b[0m`,
            
            // Bold red header
            headerTextColor: (text) => `\x1b[1;31m${text}\x1b[0m`,
            
            // Default text color
            textColor: (text) => text,
        },
    },
});
```

<Accordions>
  <Accordion title="ANSI Color Codes Reference">
    ```typescript
    const colors = {
        reset: "\x1b[0m",
        bold: "\x1b[1m",
        red: "\x1b[31m",
        green: "\x1b[32m",
        yellow: "\x1b[33m",
        blue: "\x1b[34m",
        magenta: "\x1b[35m",
        cyan: "\x1b[36m",
    };

    // Example: Cyan border
    borderColor: (text) => `${colors.cyan}${text}${colors.reset}`,

    // Example: Bold yellow header
    headerTextColor: (text) => `${colors.bold}${colors.yellow}${text}${colors.reset}`,
    ```
  </Accordion>
</Accordions>

## Error Format Customization

Individual error handlers can be customized with formatters.

<Accordions>
  <Accordion title="JSON Error Handler">
    ```typescript title="json-formatter.ts"
    import { jsonErrorHandler } from "@visulima/error-handler/error-handler/json";

    const handler = jsonErrorHandler(error, req, res, {
        formatter: (error, statusCode) => ({
            success: false,
            error: {
                message: error.message,
                code: statusCode,
                timestamp: new Date().toISOString(),
            },
        }),
    });
    ```
  </Accordion>

  <Accordion title="JSONP Error Handler">
    ```typescript title="jsonp-formatter.ts"
    import { jsonpErrorHandler } from "@visulima/error-handler/error-handler/jsonp";

    const handler = jsonpErrorHandler(error, req, res, {
        callbackName: "callback", // default
        formatter: (error, statusCode) => ({
            error: error.message,
            status: statusCode,
        }),
    });
    ```
  </Accordion>

  <Accordion title="Text Error Handler">
    ```typescript title="text-formatter.ts"
    import { textErrorHandler } from "@visulima/error-handler/error-handler/text";

    const handler = textErrorHandler(error, req, res, {
        formatter: (error, statusCode, stackTrace) => {
            return `ERROR ${statusCode}: ${error.message}\n\n${stackTrace || ""}`;
        },
    });
    ```
  </Accordion>

  <Accordion title="XML Error Handler">
    ```typescript title="xml-formatter.ts"
    import { xmlErrorHandler } from "@visulima/error-handler/error-handler/xml";

    const handler = xmlErrorHandler(error, req, res, {
        formatter: (error, statusCode) => ({
            error: {
                code: statusCode,
                message: error.message,
                timestamp: new Date().toISOString(),
            },
        }),
        xmlOptions: {
            header: true,
            indent: "  ",
        },
    });
    ```
  </Accordion>
</Accordions>

## Environment-Based Configuration

### Basic Environment Detection

```typescript title="env-config.ts"
const isDevelopment = process.env.NODE_ENV === "development";
const isProduction = process.env.NODE_ENV === "production";

const handler = await httpHandler(error, {
    showTrace: isDevelopment,
    errorPage: isProduction ? await loadProductionTemplate() : undefined,
});
```

### Advanced Environment Configuration

```typescript title="env-advanced.ts"
interface ErrorHandlerConfig {
    showTrace: boolean;
    logErrors: boolean;
    customPage: boolean;
}

const configs: Record<string, ErrorHandlerConfig> = {
    development: {
        showTrace: true,
        logErrors: true,
        customPage: false,
    },
    staging: {
        showTrace: true,
        logErrors: true,
        customPage: true,
    },
    production: {
        showTrace: false,
        logErrors: true,
        customPage: true,
    },
};

const env = process.env.NODE_ENV || "development";
const config = configs[env];

const handler = await httpHandler(error, {
    showTrace: config.showTrace,
    errorPage: config.customPage ? await loadCustomPage() : undefined,
    onError: config.logErrors ? logError : undefined,
});
```

### Configuration File

Create a configuration file:

```typescript title="error-handler.config.ts"
import type { HttpHandlerOptions } from "@visulima/error-handler";

export const errorHandlerConfig: HttpHandlerOptions = {
    showTrace: process.env.NODE_ENV !== "production",
    onError: async (error, request, response) => {
        console.error({
            timestamp: new Date().toISOString(),
            error: error.message,
            url: request.url,
        });
    },
};
```

Use in your application:

```typescript title="app.ts"
import httpHandler from "@visulima/error-handler/handler/http/node";
import { errorHandlerConfig } from "./error-handler.config";

app.use(async (err, req, res, next) => {
    const handler = await httpHandler(err, errorHandlerConfig);
    return handler(req, res);
});
```

### Per-Route Configuration

```typescript title="per-route-config.ts"
const routeConfigs = {
    api: {
        showTrace: false,
    },
    admin: {
        showTrace: true,
    },
    public: {
        showTrace: process.env.NODE_ENV !== "production",
    },
};

app.use("/api/*", async (err, req, res, next) => {
    const handler = await httpHandler(err, routeConfigs.api);
    return handler(req, res);
});

app.use("/admin/*", async (err, req, res, next) => {
    const handler = await httpHandler(err, routeConfigs.admin);
    return handler(req, res);
});

app.use(async (err, req, res, next) => {
    const handler = await httpHandler(err, routeConfigs.public);
    return handler(req, res);
});
```

## Best Practices

<Callout type="warn">
  **Security First**
  
  - Never show traces in production
  - Always sanitize error messages
  - Use CSP nonces for inline styles
  - Validate and escape user input in error messages
</Callout>

<Callout type="info">
  **Logging**
  
  - Always log errors for debugging
  - Include request context in logs
  - Use structured logging
  - Send errors to monitoring services
</Callout>

<Callout type="tip">
  **Performance**
  
  - Cache error templates
  - Use async logging (fire and forget)
  - Avoid expensive operations in error handlers
  - Consider rate limiting error responses
</Callout>

<Callout type="info">
  **User Experience**
  
  - Provide helpful error messages
  - Use branded error pages in production
  - Include support contact information
  - Add error tracking IDs for support
</Callout>
