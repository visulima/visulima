import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";

import UNICODE_MAP from "../data/transliteration.json" assert { type: "json" };

const inputCharmapModulePath = "./src/charmap"; // Path for import
const outputDir = "./src/charmap"; // Output directory relative to project root
const mapFileName = "index.ts";
const oldCharmapFileToDelete = "./src/charmap.ts"; // Path relative to project root

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = resolve(join(__dirname, "..")); // Assumes script is in project root

const outputDirpath = join(projectRoot, outputDir);
const mapFilepath = join(outputDirpath, mapFileName);
const oldCharmapFilepath = join(projectRoot, oldCharmapFileToDelete);

async function runSplit() {
    console.log(`Attempting to import UNICODE_MAP from: ${inputCharmapModulePath}`);

    // --- File Generation ---
    console.log(`Creating output directory: ${outputDirpath}`);
    mkdirSync(outputDirpath, { recursive: true });

    /**
     * @type {Array<{name: string, file: string}>}
     */
    const blockExports = [];

    Object.values(UNICODE_MAP).forEach((blockData, blockIndex) => {
        if (!Array.isArray(blockData) || blockData.length === 0) {
            console.warn(`Skipping invalid block data at index ${blockIndex}.`);
            return;
        }

        const blockStart = (blockIndex * 256).toString(16).toUpperCase().padStart(4, "0");
        const blockEnd = (blockIndex * 256 + blockData.length - 1).toString(16).toUpperCase().padStart(4, "0"); // Use actual length
        const blockName = `UNICODE_BLOCK_${blockStart}_${blockEnd}`;
        const blockFilename = `block-${blockStart.toLowerCase()}-${blockEnd.toLowerCase()}.ts`;
        const blockFilepath = join(outputDirpath, blockFilename);

        // Format the array data for the TS file content
        const blockContentString = JSON.stringify(blockData, null, 4).replace(/null/g, "undefined"); // Convert null back to undefined if necessary

        const fileContent =
            `// Block 0x${blockIndex.toString(16).toUpperCase().padStart(2, "0")} (U+${blockStart} to U+${blockEnd})\n` +
            `const ${blockName}: (string | undefined)[] = ${blockContentString};\n\n export default ${blockName};\n`;

        try {
            writeFileSync(blockFilepath, fileContent, "utf8");
            
            console.log(`Created: ${blockFilename}`);
            
            blockExports.push({ name: blockName, file: `./${blockFilename.replace(".ts", "")}` });
        } catch (err) {
            console.error(`Error writing file ${blockFilename}:`, err);
        }
    });

    console.log(`Generating ${mapFileName}...`);
    
    const mapBlocksArray = blockExports.map((exp) => `    ${exp.name},`).join("\n");

    const mapFileContent = `// This file is auto-generated by the generate-charmap.js script.
// Do not edit this file manually.

import type { Charmap } from "../types";
${blockExports.map((exp) => `import ${exp.name} from "${exp.file}";`).join("\n")}

let unicodeBlocks: undefined | (string | undefined)[][] = [
${mapBlocksArray}
];

const generatedCharmap: Record<string, string> = {};

unicodeBlocks.forEach((block, blockIndex) => {
    if (block) {
        // Assuming each block constant represents 256 code points (0x100)
        const baseCode = blockIndex * 0x100;

        block.forEach((replacement, charIndex) => {
            if (typeof replacement === "string") { // Only map if a replacement string exists
                const charCode = baseCode + charIndex;

                try {
                    const originalChar = String.fromCharCode(charCode);

                    if (originalChar && !generatedCharmap[originalChar]) {
                        generatedCharmap[originalChar] = replacement;
                    }
                } catch (e) {
                    // Ignore errors for invalid char codes
                }
            }
        });
    }
});

export default Object.freeze(generatedCharmap) as Charmap;

// reset memory
unicodeBlocks = undefined;
`;

    try {
        writeFileSync(mapFilepath, mapFileContent, "utf8");
        console.log(`Created: ${mapFileName}`);
    } catch (err) {
        console.error(`Error writing file ${mapFileName}:`, err);
    }

    console.log("\n--- Script Finished ---");
    console.log(`1. Verify the files generated in: ${outputDirpath}`);
    console.log(`2. IMPORTANT: Manually delete the old file: ${oldCharmapFilepath}`);
    console.log(`3. Update imports in 'src/transliterate.ts' and tests to point to './charmap/map' if not already done.`);
    console.log(`4. Uncomment and adjust manual overrides in '${mapFileName}' if needed.`);
    console.log("5. Run tests for the package.");
}

runSplit().catch(console.error);
