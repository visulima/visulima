import { mkdirSync, rmSync, writeFileSync } from "node:fs";
import { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";

import UNICODE_MAP from "../data/transliteration.json" assert { type: "json" };

/**
 * Checks if a character is Chinese.
 * @param {number} low - The Unicode code point of the character.
 * @returns {boolean} True if the character is Chinese, false otherwise.
 */
const isChinese = (low) => (low >= 0x4e && low <= 0x9f) || (low >= 0xf9 && low <= 0xfa);

const inputCharmapModulePath = "./src/charmap"; // Path for import
const outputDir = "./src/charmap"; // Output directory relative to project root
const mapFileName = "index.ts";
const oldCharmapFileToDelete = "./src/charmap.ts"; // Path relative to project root

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = resolve(join(__dirname, "..")); // Assumes script is in project root

const outputDirpath = join(projectRoot, outputDir);
const mapFilepath = join(outputDirpath, mapFileName);
const oldCharmapFilepath = join(projectRoot, oldCharmapFileToDelete);

async function runSplit() {
    console.log(`Attempting to import UNICODE_MAP from: ${inputCharmapModulePath}`);

    console.log(`Creating output directory: ${outputDirpath}`);
    rmSync(outputDirpath, { force: true, recursive: true });
    mkdirSync(outputDirpath, { recursive: true });

    /**
     * @type {Array<{name: string, file: string, index: string}>}
     */
    const blockExports = [];

    Object.entries(UNICODE_MAP).forEach(([blockIndex, blockData]) => {
        if (!Array.isArray(blockData) || blockData.length === 0) {
            console.warn(`Skipping invalid block data at index ${blockIndex}.`);
            return;
        }

        const blockStart = (Number(blockIndex) * 256).toString(16).toUpperCase().padStart(4, "0");
        const blockEnd = (Number(blockIndex) * 256 + blockData.length - 1).toString(16).toUpperCase().padStart(4, "0"); // Use actual length
        const blockName = `UNICODE_BLOCK_${blockStart}_${blockEnd}`;
        const blockFilename = `block-${blockStart.toLowerCase()}-${blockEnd.toLowerCase()}.ts`;
        const blockFilepath = join(outputDirpath, blockFilename);

        for (let i = 0; i < blockData.length; i++) {
            const char = blockData[i];

            if (char === undefined || char === null || char === "") {
                blockData[i] = null;
            } else if (isChinese(Number(blockIndex))) {
                blockData[i] = char.trimEnd();
            }
        }

        // Format the array data for the TS file content
        const blockContentString = JSON.stringify(blockData, null, 4).replaceAll("null", "undefined"); // Convert null back to undefined if necessary

        const fileContent =
            "// This file is auto-generated by the generate-charmap.js script.\n// Do not edit this file manually.\n" +
            `// Block [${blockIndex}] 0x${blockIndex.toUpperCase().padStart(2, "0")} (U+${blockStart} to U+${blockEnd})\n` +
            `const ${blockName}: (string | undefined)[] = ${blockContentString};\n\n export default ${blockName};\n`;

        try {
            writeFileSync(blockFilepath, fileContent, "utf8");

            console.log(`Created: ${blockFilename}`);

            blockExports.push({ file: `./${blockFilename.replace(".ts", "")}`, name: blockName, index: blockIndex });
        } catch (error) {
            console.error(`Error writing file ${blockFilename}:`, error);
        }
    });

    console.log(`Generating ${mapFileName}...`);

    const importStatements = blockExports.map((exp) => `import ${exp.name} from "${exp.file}";`).join("\n");
    const blockDataMapEntries = blockExports.map((exp) => `    '${exp.index}': ${exp.name}`).join(",\n");

    const mapFileContent = `// This file is auto-generated by the generate-charmap.js script.
// Do not edit this file manually.

import type { Charmap } from "../types";
${importStatements}

// Map block indices (as strings) to the imported block data arrays
const blockDataMap: Record<string, (string | undefined)[]> = Object.freeze({
${blockDataMapEntries}
});

const generatedCharmap: Record<string, string> = {};

for (const blockIndexString in blockDataMap) {
    if (Object.prototype.hasOwnProperty.call(blockDataMap, blockIndexString)) {
        const blockData = blockDataMap[blockIndexString];

        if (blockData) {
            const baseCode = Number(blockIndexString) * 0x100;
            const blockLength = blockData.length;

            for (let charIndex = 0; charIndex < blockLength; charIndex++) {
                const replacement = blockData[charIndex];

                if (typeof replacement === "string") {
                    const charCode = baseCode + charIndex;

                    try {
                        const originalChar = String.fromCodePoint(charCode);

                        if (originalChar && !generatedCharmap[originalChar]) {
                            generatedCharmap[originalChar] = replacement;
                        }
                    } catch (error_) {
                        // Ignore errors for invalid char codes (like surrogates)
                        // console.warn(\`Skipping invalid charCode \${charCode.toString(16)}: \${error_}\`);
                    }
                }
            }
        }
    }
}

export default Object.freeze(generatedCharmap) as Charmap;
`;

    try {
        writeFileSync(mapFilepath, mapFileContent, "utf8");
        console.log(`Created: ${mapFileName}`);
    } catch (error) {
        console.error(`Error writing file ${mapFileName}:`, error);
    }

    console.log("\n--- Script Finished ---");
    console.log(`1. Verify the files generated in: ${outputDirpath}`);
    console.log(`2. IMPORTANT: Manually delete the old file: ${oldCharmapFilepath}`);
    console.log(`3. Update imports in 'src/transliterate.ts' and tests to point to './charmap/map' if not already done.`);
    console.log(`4. Uncomment and adjust manual overrides in '${mapFileName}' if needed.`);
    console.log("5. Run tests for the package.");
}

runSplit().catch(console.error);
