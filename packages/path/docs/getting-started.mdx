---
title: Getting Started
description: Learn the basics of using @visulima/path in your projects
---

This guide will help you understand the basics of using `@visulima/path` in your projects.

## Basic Usage

### Importing the Library

The simplest way to use `@visulima/path` is as a drop-in replacement for Node.js's path module:

<Tabs items={['ESM', 'CommonJS']}>
  <Tab value="ESM">
    ```typescript
    import path from '@visulima/path';
    // or import individual functions
    import { resolve, join, dirname, basename } from '@visulima/path';
    ```
  </Tab>
  <Tab value="CommonJS">
    ```javascript
    const path = require('@visulima/path');
    // or import individual functions
    const { resolve, join, dirname, basename } = require('@visulima/path');
    ```
  </Tab>
</Tabs>

### Your First Path Operations

#### Joining Paths

Combine multiple path segments into a single path:

```javascript
import { join } from '@visulima/path';

const fullPath = join('users', 'john', 'documents', 'file.txt');
console.log(fullPath); // Output: users/john/documents/file.txt
```

#### Resolving Absolute Paths

Convert a sequence of paths into an absolute path:

```javascript
import { resolve } from '@visulima/path';

// Assuming current working directory is /home/user
const absolutePath = resolve('projects', 'my-app', 'src');
console.log(absolutePath); // Output: /home/user/projects/my-app/src
```

#### Getting Directory and Filename

Extract the directory name or filename from a path:

```javascript
import { dirname, basename } from '@visulima/path';

const filePath = '/home/user/documents/report.pdf';

const directory = dirname(filePath);
console.log(directory); // Output: /home/user/documents

const filename = basename(filePath);
console.log(filename); // Output: report.pdf

const nameWithoutExt = basename(filePath, '.pdf');
console.log(nameWithoutExt); // Output: report
```

## Working with Different Path Types

### Relative Paths

```javascript
import { relative } from '@visulima/path';

const from = '/home/user/projects';
const to = '/home/user/documents/file.txt';

const relativePath = relative(from, to);
console.log(relativePath); // Output: ../../documents/file.txt
```

### Normalizing Paths

Clean up paths with redundant separators or `.` and `..` segments:

```javascript
import { normalize } from '@visulima/path';

const messyPath = '/home/user/../user/./documents//file.txt';
const cleanPath = normalize(messyPath);
console.log(cleanPath); // Output: /home/user/documents/file.txt
```

### Parsing Paths

Break down a path into its components:

```javascript
import { parse } from '@visulima/path';

const parsed = parse('/home/user/documents/report.pdf');
console.log(parsed);
// Output:
// {
//   root: '/',
//   dir: '/home/user/documents',
//   base: 'report.pdf',
//   ext: '.pdf',
//   name: 'report'
// }
```

### Formatting Paths

Build a path from its components:

```javascript
import { format } from '@visulima/path';

const pathObject = {
  root: '/',
  dir: '/home/user/documents',
  base: 'report.pdf'
};

const formatted = format(pathObject);
console.log(formatted); // Output: /home/user/documents/report.pdf
```

## Using Utility Functions

`@visulima/path` includes additional utilities not available in the standard path module. Import them from the `/utils` subpath:

<Tabs items={['ESM', 'CommonJS']}>
  <Tab value="ESM">
    ```typescript
    import { 
      filename, 
      isRelative, 
      isBinaryPath,
      normalizeAliases,
      resolveAlias 
    } from '@visulima/path/utils';
    ```
  </Tab>
  <Tab value="CommonJS">
    ```javascript
    const { 
      filename, 
      isRelative, 
      isBinaryPath,
      normalizeAliases,
      resolveAlias 
    } = require('@visulima/path/utils');
    ```
  </Tab>
</Tabs>

### Extract Filename Without Extension

```javascript
import { filename } from '@visulima/path/utils';

const name = filename('/home/user/documents/report.pdf');
console.log(name); // Output: report
```

### Check if Path is Relative

```javascript
import { isRelative } from '@visulima/path/utils';

console.log(isRelative('./foo/bar')); // Output: true
console.log(isRelative('../foo/bar')); // Output: true
console.log(isRelative('/foo/bar')); // Output: false
```

### Detect Binary Files

```javascript
import { isBinaryPath } from '@visulima/path/utils';

console.log(isBinaryPath('image.jpg')); // Output: true
console.log(isBinaryPath('script.js')); // Output: false
console.log(isBinaryPath('app.exe')); // Output: true
```

### Working with Path Aliases

Path aliases are useful for maintaining clean import paths in your projects:

```javascript
import { normalizeAliases, resolveAlias } from '@visulima/path/utils';

// Define your aliases
const aliases = normalizeAliases({
  '@': '/project/src',
  '@components': '@/components',
  '@utils': '@/utils'
});

// Resolve an aliased path
const resolved = resolveAlias('@components/Button.tsx', aliases);
console.log(resolved); // Output: /project/src/components/Button.tsx
```

## Common Patterns

### Building File Paths

```javascript
import { join, resolve } from '@visulima/path';

// Relative to current directory
const configPath = join(process.cwd(), 'config', 'app.json');

// Relative to a specific base directory
const projectRoot = '/home/user/project';
const sourcePath = join(projectRoot, 'src', 'index.ts');
```

### Checking Path Properties

```javascript
import { isAbsolute, extname } from '@visulima/path';

const path1 = '/home/user/file.txt';
const path2 = './relative/file.txt';

console.log(isAbsolute(path1)); // Output: true
console.log(isAbsolute(path2)); // Output: false

console.log(extname(path1)); // Output: .txt
```

### Converting Between Formats

```javascript
import { normalize } from '@visulima/path';

// Convert Windows-style paths to POSIX-style
const windowsPath = 'C:\\Users\\John\\Documents\\file.txt';
const posixPath = normalize(windowsPath);
console.log(posixPath); // Output: C:/Users/John/Documents/file.txt
```

## Best Practices

<Callout type="info" title="Best Practices">

**1. Always use forward slashes in your code**

Let `@visulima/path` handle the normalization.

```javascript
// Good
join('src', 'components', 'Button.tsx')

// Avoid (but still works)
join('src\\components\\Button.tsx')
```

**2. Use `resolve()` for absolute paths**

When you need an absolute path, use `resolve()` rather than manually concatenating with `process.cwd()`.

```javascript
// Good
const absolutePath = resolve('src', 'index.ts');

// Avoid
const absolutePath = join(process.cwd(), 'src', 'index.ts');
```

**3. Prefer path operations over string manipulation**

Use path functions instead of string operations.

```javascript
// Good
const dir = dirname(filePath);
const base = basename(filePath);

// Avoid
const parts = filePath.split('/');
const base = parts[parts.length - 1];
```

**4. Use utilities for common tasks**

Take advantage of the utility functions.

```javascript
import { isRelative } from '@visulima/path/utils';

// Good
if (isRelative(inputPath)) { /* ... */ }

// Avoid
if (inputPath.startsWith('./') || inputPath.startsWith('../')) { /* ... */ }
```

</Callout>

## Next Steps

<Cards>
  <Card title="API Reference" href="./api-reference">
    Explore the complete API documentation
  </Card>
  <Card title="Utility Functions" href="./utility-functions">
    Learn about additional helper functions
  </Card>
  <Card title="Examples" href="./examples">
    See more real-world examples
  </Card>
  <Card title="Migration Guide" href="./migration-guide">
    Migrate from Node.js path module
  </Card>
</Cards>
