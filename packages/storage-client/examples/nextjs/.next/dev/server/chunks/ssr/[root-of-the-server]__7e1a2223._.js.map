{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/createChunkedRestAdapter-tTCb4Zfg.js"],"sourcesContent":["const DEFAULT_CHUNK_SIZE = 5 * 1024 * 1024;\nconst createChunkedRestAdapter = (options) => {\n  const { chunkSize = DEFAULT_CHUNK_SIZE, endpoint, maxRetries = 3, metadata = {}, retry = true } = options;\n  let uploadState = {\n    aborted: false,\n    paused: false,\n    totalSize: 0,\n    uploadedChunks: /* @__PURE__ */ new Set()\n  };\n  let startCallback;\n  let progressCallback;\n  let finishCallback;\n  let errorCallback;\n  const fetchWithRetry = async (url, init, retriesLeft = maxRetries) => {\n    try {\n      const response = await fetch(url, init);\n      if (!response.ok && retriesLeft > 0 && retry) {\n        const delay = 1e3 * 2 ** (maxRetries - retriesLeft);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        return fetchWithRetry(url, init, retriesLeft - 1);\n      }\n      return response;\n    } catch (error) {\n      if (retriesLeft > 0 && retry) {\n        const delay = 1e3 * 2 ** (maxRetries - retriesLeft);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        return fetchWithRetry(url, init, retriesLeft - 1);\n      }\n      throw error;\n    }\n  };\n  const createUpload = async (file) => {\n    const headers = {\n      \"Content-Type\": file.type || \"application/octet-stream\",\n      \"X-Chunked-Upload\": \"true\",\n      \"X-Total-Size\": String(file.size)\n    };\n    if (Object.keys(metadata).length > 0) {\n      headers[\"X-File-Metadata\"] = JSON.stringify(metadata);\n    }\n    if (file.name) {\n      headers[\"Content-Disposition\"] = `attachment; filename=\"${file.name}\"`;\n    }\n    const response = await fetchWithRetry(endpoint, {\n      body: new Uint8Array(0),\n      // Empty body for initialization\n      headers,\n      method: \"POST\"\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create upload session: ${response.status} ${response.statusText}`);\n    }\n    const fileId = response.headers.get(\"X-Upload-ID\") || response.headers.get(\"Location\")?.split(\"/\").pop();\n    if (!fileId) {\n      throw new Error(\"Failed to get upload ID from server\");\n    }\n    return fileId;\n  };\n  const getUploadStatus = async (fileId) => {\n    const url = endpoint.endsWith(\"/\") ? `${endpoint}${fileId}` : `${endpoint}/${fileId}`;\n    const response = await fetchWithRetry(url, {\n      method: \"HEAD\"\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to get upload status: ${response.status} ${response.statusText}`);\n    }\n    const offset = Number.parseInt(response.headers.get(\"X-Upload-Offset\") || \"0\", 10);\n    const chunksHeader = response.headers.get(\"X-Received-Chunks\");\n    let chunks = [];\n    if (chunksHeader) {\n      try {\n        const parsed = JSON.parse(chunksHeader);\n        if (Array.isArray(parsed)) {\n          chunks = parsed;\n        }\n      } catch {\n      }\n    }\n    return { chunks, offset };\n  };\n  const uploadChunk = async (file, fileId, startOffset, endOffset, signal) => {\n    const chunk = file.slice(startOffset, endOffset);\n    const chunkSize2 = endOffset - startOffset;\n    if (uploadState.uploadedChunks.has(startOffset)) {\n      return;\n    }\n    const url = endpoint.endsWith(\"/\") ? `${endpoint}${fileId}` : `${endpoint}/${fileId}`;\n    const response = await fetchWithRetry(url, {\n      body: chunk,\n      headers: {\n        \"Content-Length\": String(chunkSize2),\n        \"Content-Type\": \"application/octet-stream\",\n        \"X-Chunk-Offset\": String(startOffset)\n      },\n      method: \"PATCH\",\n      signal\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to upload chunk: ${response.status} ${response.statusText}`);\n    }\n    uploadState.uploadedChunks.add(startOffset);\n    const currentOffset = Number.parseInt(response.headers.get(\"X-Upload-Offset\") || String(endOffset), 10);\n    const progress = Math.round(currentOffset / file.size * 100);\n    progressCallback?.(progress, currentOffset);\n  };\n  const performUpload = async (file, fileId, signal) => {\n    const totalChunks = Math.ceil(file.size / chunkSize);\n    const { chunks: serverChunks } = await getUploadStatus(fileId);\n    for (const chunk of serverChunks) {\n      uploadState.uploadedChunks.add(chunk.offset);\n    }\n    const uploadPromises = [];\n    for (let i = 0; i < totalChunks; i++) {\n      const startOffset = i * chunkSize;\n      const endOffset = Math.min(startOffset + chunkSize, file.size);\n      if (uploadState.uploadedChunks.has(startOffset)) {\n        continue;\n      }\n      while (uploadState.paused && !uploadState.aborted) {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n      if (uploadState.aborted) {\n        throw new Error(\"Upload aborted\");\n      }\n      uploadPromises.push(uploadChunk(file, fileId, startOffset, endOffset, signal));\n    }\n    await Promise.all(uploadPromises);\n    const finalStatus = await getUploadStatus(fileId);\n    if (finalStatus.offset < file.size) {\n      throw new Error(`Upload incomplete. Expected ${file.size} bytes, got ${finalStatus.offset}`);\n    }\n    const url = endpoint.endsWith(\"/\") ? `${endpoint}${fileId}` : `${endpoint}/${fileId}`;\n    const response = await fetchWithRetry(url, {\n      method: \"GET\"\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to get upload result: ${response.status} ${response.statusText}`);\n    }\n    const fileMeta = await response.json();\n    return {\n      bytesWritten: fileMeta.bytesWritten || file.size,\n      contentType: fileMeta.contentType || file.type,\n      createdAt: fileMeta.createdAt,\n      filename: fileMeta.originalName || file.name,\n      id: fileMeta.id || fileId,\n      metadata: fileMeta.metadata,\n      name: fileMeta.name,\n      originalName: fileMeta.originalName || file.name,\n      size: fileMeta.size || file.size,\n      status: fileMeta.status || \"completed\",\n      url: fileMeta.url\n    };\n  };\n  return {\n    /**\n     * Abort current upload\n     */\n    abort: () => {\n      uploadState.aborted = true;\n      uploadState.paused = false;\n      uploadState.abortController?.abort();\n    },\n    /**\n     * Clear upload state\n     */\n    clear: () => {\n      uploadState = {\n        abortController: void 0,\n        aborted: false,\n        paused: false,\n        totalSize: 0,\n        uploadedChunks: /* @__PURE__ */ new Set()\n      };\n    },\n    /**\n     * Get current upload offset\n     */\n    getOffset: async () => {\n      if (!uploadState.fileId) {\n        return 0;\n      }\n      try {\n        const status = await getUploadStatus(uploadState.fileId);\n        return status.offset;\n      } catch {\n        return [...uploadState.uploadedChunks].reduce((sum, offset) => {\n          const chunkEnd = Math.min(offset + chunkSize, uploadState.totalSize);\n          return sum + (chunkEnd - offset);\n        }, 0);\n      }\n    },\n    /**\n     * Check if upload is paused\n     */\n    isPaused: () => uploadState.paused,\n    /**\n     * Pause upload\n     */\n    pause: () => {\n      uploadState.paused = true;\n    },\n    /**\n     * Resume upload\n     */\n    resume: async () => {\n      if (!uploadState.fileId || !uploadState.file) {\n        throw new Error(\"No upload to resume\");\n      }\n      uploadState.paused = false;\n      const abortController = new AbortController();\n      uploadState.abortController = abortController;\n      try {\n        const result = await performUpload(uploadState.file, uploadState.fileId, abortController.signal);\n        finishCallback?.(result);\n      } catch (error) {\n        const uploadError = error instanceof Error ? error : new Error(String(error));\n        errorCallback?.(uploadError);\n        throw uploadError;\n      }\n    },\n    /**\n     * Set error callback\n     */\n    setOnError: (callback) => {\n      errorCallback = callback;\n    },\n    /**\n     * Set finish callback\n     */\n    setOnFinish: (callback) => {\n      finishCallback = callback;\n    },\n    /**\n     * Set progress callback\n     */\n    setOnProgress: (callback) => {\n      progressCallback = callback;\n    },\n    /**\n     * Set start callback\n     */\n    setOnStart: (callback) => {\n      startCallback = callback;\n    },\n    /**\n     * Upload a file in chunks\n     */\n    upload: async (file) => new Promise((resolve, reject) => {\n      let resolved = false;\n      const originalFinishCallback = finishCallback;\n      const originalErrorCallback = errorCallback;\n      let timeoutId;\n      const cleanupTimeout = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = void 0;\n        }\n        finishCallback = originalFinishCallback;\n        errorCallback = originalErrorCallback;\n      };\n      const internalFinishCallback = (result) => {\n        if (!resolved) {\n          resolved = true;\n          cleanupTimeout();\n          originalFinishCallback?.(result);\n          resolve(result);\n        }\n      };\n      const internalErrorCallback = (error) => {\n        if (!resolved) {\n          resolved = true;\n          cleanupTimeout();\n          originalErrorCallback?.(error);\n          reject(error);\n        }\n      };\n      finishCallback = internalFinishCallback;\n      errorCallback = internalErrorCallback;\n      uploadState = {\n        aborted: false,\n        file,\n        paused: false,\n        totalSize: file.size,\n        uploadedChunks: /* @__PURE__ */ new Set()\n      };\n      startCallback?.();\n      (async () => {\n        try {\n          const abortController = new AbortController();\n          uploadState.abortController = abortController;\n          const fileId = await createUpload(file);\n          uploadState.fileId = fileId;\n          const result = await performUpload(file, fileId, abortController.signal);\n          internalFinishCallback(result);\n        } catch (error) {\n          const uploadError = error instanceof Error ? error : new Error(String(error));\n          internalErrorCallback(uploadError);\n        }\n      })();\n      timeoutId = setTimeout(() => {\n        if (!resolved) {\n          uploadState.aborted = true;\n          cleanupTimeout();\n          internalErrorCallback(new Error(\"Upload timeout\"));\n        }\n      }, 3e5);\n    })\n  };\n};\n\nexport { createChunkedRestAdapter };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/useChunkedRestUpload-DOPSk-t6.js"],"sourcesContent":["import { useState, useMemo, useRef, useEffect, useCallback } from 'react';\nimport { createChunkedRestAdapter } from './createChunkedRestAdapter-tTCb4Zfg.js';\n\nconst useChunkedRestUpload = (options) => {\n  const { chunkSize, endpoint, maxRetries, metadata, onError, onPause, onProgress, onResume, onStart, onSuccess, retry } = options;\n  const [progress, setProgress] = useState(0);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [error, setError] = useState(null);\n  const [result, setResult] = useState(null);\n  const [offset, setOffset] = useState(0);\n  const adapterInstance = useMemo(\n    () => createChunkedRestAdapter({\n      chunkSize,\n      endpoint,\n      maxRetries,\n      metadata,\n      retry\n    }),\n    [chunkSize, endpoint, maxRetries, metadata, retry]\n  );\n  const callbacksRef = useRef({ onError, onPause, onProgress, onResume, onStart, onSuccess });\n  useEffect(() => {\n    callbacksRef.current = { onError, onPause, onProgress, onResume, onStart, onSuccess };\n  }, [onError, onProgress, onPause, onResume, onStart, onSuccess]);\n  useEffect(() => {\n    adapterInstance.setOnStart(() => {\n      setIsUploading(true);\n      setIsPaused(false);\n      setProgress(0);\n      setError(null);\n      setOffset(0);\n      callbacksRef.current.onStart?.();\n    });\n    adapterInstance.setOnProgress((progressValue, offsetValue) => {\n      setProgress(progressValue);\n      setOffset(offsetValue);\n      callbacksRef.current.onProgress?.(progressValue, offsetValue);\n    });\n    adapterInstance.setOnFinish((uploadResult) => {\n      setProgress(100);\n      setResult(uploadResult);\n      setIsUploading(false);\n      setIsPaused(false);\n      callbacksRef.current.onSuccess?.(uploadResult);\n    });\n    adapterInstance.setOnError((uploadError) => {\n      setError(uploadError);\n      setIsUploading(false);\n      callbacksRef.current.onError?.(uploadError);\n    });\n    const checkInterval = setInterval(async () => {\n      setOffset(await adapterInstance.getOffset());\n      setIsPaused(adapterInstance.isPaused());\n    }, 100);\n    return () => {\n      clearInterval(checkInterval);\n      adapterInstance.setOnStart(void 0);\n      adapterInstance.setOnProgress(void 0);\n      adapterInstance.setOnFinish(void 0);\n      adapterInstance.setOnError(void 0);\n    };\n  }, [adapterInstance]);\n  const upload = useCallback(\n    async (file) => {\n      try {\n        return await adapterInstance.upload(file);\n      } catch (error_) {\n        const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n        setError(uploadError);\n        callbacksRef.current.onError?.(uploadError);\n        throw uploadError;\n      }\n    },\n    [adapterInstance]\n  );\n  const pause = useCallback(() => {\n    adapterInstance.pause();\n    setIsPaused(true);\n    callbacksRef.current.onPause?.();\n  }, [adapterInstance]);\n  const resume = useCallback(async () => {\n    setIsPaused(false);\n    setIsUploading(true);\n    callbacksRef.current.onResume?.();\n    try {\n      await adapterInstance.resume();\n    } catch (error_) {\n      const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n      setError(uploadError);\n      setIsUploading(false);\n      callbacksRef.current.onError?.(uploadError);\n      throw uploadError;\n    }\n  }, [adapterInstance]);\n  const abort = useCallback(() => {\n    adapterInstance.abort();\n    setIsUploading(false);\n    setIsPaused(false);\n  }, [adapterInstance]);\n  const reset = useCallback(() => {\n    adapterInstance.clear();\n    setProgress(0);\n    setIsUploading(false);\n    setIsPaused(false);\n    setError(null);\n    setResult(null);\n    setOffset(0);\n  }, [adapterInstance]);\n  return {\n    abort,\n    error,\n    isPaused,\n    isUploading,\n    offset,\n    pause,\n    progress,\n    reset,\n    result,\n    resume,\n    upload\n  };\n};\n\nexport { useChunkedRestUpload };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/createUploader-DVuRBCmu.js"],"sourcesContent":["class Uploader {\n  constructor(options) {\n    this.options = options;\n  }\n  items = /* @__PURE__ */ new Map();\n  eventHandlers = /* @__PURE__ */ new Map();\n  activeUploads = /* @__PURE__ */ new Map();\n  itemIdCounter = 0;\n  /**\n   * Generate unique item ID\n   */\n  generateItemId() {\n    this.itemIdCounter += 1;\n    return `item-${Date.now()}-${this.itemIdCounter}`;\n  }\n  /**\n   * Subscribe to uploader events\n   */\n  on(event, handler) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventHandlers.get(event)?.add(handler);\n  }\n  /**\n   * Unsubscribe from uploader events\n   */\n  off(event, handler) {\n    this.eventHandlers.get(event)?.delete(handler);\n  }\n  /**\n   * Emit event to all registered handlers\n   */\n  emit(event, item) {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach((handler) => {\n        try {\n          handler(item);\n        } catch (error) {\n          console.error(`[Uploader] Error in ${event} handler:`, error);\n        }\n      });\n    }\n  }\n  /**\n   * Create FormData for visulima multipart handler\n   */\n  createFormData(file, metadata) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (metadata && Object.keys(metadata).length > 0) {\n      formData.append(\"metadata\", JSON.stringify(metadata));\n    }\n    return formData;\n  }\n  /**\n   * Parse response as FileMeta\n   */\n  parseResponse(responseText, response) {\n    try {\n      const parsed = JSON.parse(responseText);\n      return parsed;\n    } catch {\n      const contentType = response instanceof XMLHttpRequest ? response.getResponseHeader(\"Content-Type\") : response.headers.get(\"Content-Type\");\n      if (contentType?.includes(\"application/json\")) {\n        try {\n          return JSON.parse(responseText);\n        } catch {\n        }\n      }\n      return {};\n    }\n  }\n  /**\n   * Upload a single file\n   */\n  async uploadFile(item) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      const formData = this.createFormData(item.file, this.options.metadata);\n      this.activeUploads.set(item.id, xhr);\n      item.status = \"uploading\";\n      this.items.set(item.id, item);\n      this.emit(\"ITEM_START\", item);\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const { loaded } = event;\n          const { total } = event;\n          const completed = Math.round(loaded / total * 100);\n          item.loaded = loaded;\n          item.completed = completed;\n          item.size = total;\n          this.items.set(item.id, item);\n          this.emit(\"ITEM_PROGRESS\", item);\n        }\n      });\n      xhr.addEventListener(\"load\", () => {\n        this.activeUploads.delete(item.id);\n        if (xhr.status >= 200 && xhr.status < 300) {\n          const responseText = xhr.responseText || xhr.response;\n          const fileMeta = this.parseResponse(responseText, xhr);\n          item.status = \"completed\";\n          item.uploadResponse = {\n            data: fileMeta,\n            response: responseText\n          };\n          item.url = fileMeta.url || xhr.getResponseHeader(\"Location\") || void 0;\n          this.items.set(item.id, item);\n          this.emit(\"ITEM_FINISH\", item);\n          resolve();\n        } else {\n          const error = new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`);\n          item.status = \"error\";\n          item.error = error.message;\n          this.items.set(item.id, item);\n          this.emit(\"ITEM_ERROR\", item);\n          reject(error);\n        }\n      });\n      xhr.addEventListener(\"error\", () => {\n        this.activeUploads.delete(item.id);\n        const error = new Error(\"Network error during upload\");\n        item.status = \"error\";\n        item.error = error.message;\n        this.items.set(item.id, item);\n        this.emit(\"ITEM_ERROR\", item);\n        reject(error);\n      });\n      xhr.addEventListener(\"abort\", () => {\n        this.activeUploads.delete(item.id);\n        item.status = \"aborted\";\n        this.items.set(item.id, item);\n        reject(new Error(\"Upload aborted\"));\n      });\n      xhr.open(\"POST\", this.options.endpoint, true);\n      if (this.options.metadata) {\n        xhr.setRequestHeader(\"X-File-Metadata\", JSON.stringify(this.options.metadata));\n      }\n      xhr.send(formData);\n    });\n  }\n  /**\n   * Add file to upload queue\n   */\n  add(file) {\n    const id = this.generateItemId();\n    const item = {\n      completed: 0,\n      file,\n      id,\n      loaded: 0,\n      size: file.size,\n      status: \"pending\"\n    };\n    this.items.set(id, item);\n    this.uploadFile(item).catch((error) => {\n      console.error(`[Uploader] Upload failed for item ${id}:`, error);\n    });\n    return id;\n  }\n  /**\n   * Get item by ID\n   */\n  getItem(id) {\n    return this.items.get(id);\n  }\n  /**\n   * Abort specific upload\n   */\n  abortItem(id) {\n    const xhr = this.activeUploads.get(id);\n    if (xhr) {\n      xhr.abort();\n      this.activeUploads.delete(id);\n    }\n    const item = this.items.get(id);\n    if (item) {\n      item.status = \"aborted\";\n      this.items.set(id, item);\n    }\n  }\n  /**\n   * Abort all uploads\n   */\n  abort() {\n    this.activeUploads.forEach((xhr, id) => {\n      xhr.abort();\n      this.abortItem(id);\n    });\n    this.activeUploads.clear();\n  }\n  /**\n   * Clear all items and abort active uploads\n   */\n  clear() {\n    this.abort();\n    this.items.clear();\n  }\n  /**\n   * Get all items\n   */\n  getItems() {\n    return [...this.items.values()];\n  }\n}\nconst createUploader = (options) => new Uploader(options);\n\nexport { Uploader, createUploader };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/createMultipartAdapter-zOB0rL96.js"],"sourcesContent":["import { createUploader } from './createUploader-DVuRBCmu.js';\n\nconst createMultipartAdapter = (options) => {\n  const uploader = createUploader({\n    endpoint: options.endpoint,\n    maxRetries: options.maxRetries,\n    metadata: options.metadata,\n    retry: options.retry\n  });\n  return {\n    /**\n     * Abort all uploads\n     */\n    abort: () => {\n      uploader.abort();\n    },\n    /**\n     * Clear all uploads\n     */\n    clear: () => {\n      uploader.clear();\n    },\n    /**\n     * Upload a file and return visulima-compatible result\n     */\n    upload: async (file) => new Promise((resolve, reject) => {\n      let uploadResult;\n      let resolved = false;\n      const cleanup = () => {\n        uploader.off(\"ITEM_FINISH\", onItemFinish);\n        uploader.off(\"ITEM_ERROR\", onError);\n      };\n      const onItemFinish = (item) => {\n        if (!resolved && item.file.name === file.name) {\n          let fileMeta = {};\n          try {\n            if (item.uploadResponse?.data && typeof item.uploadResponse.data === \"object\") {\n              fileMeta = item.uploadResponse.data;\n            } else if (item.uploadResponse?.response) {\n              fileMeta = JSON.parse(item.uploadResponse.response);\n            }\n          } catch {\n          }\n          uploadResult = {\n            bytesWritten: fileMeta.bytesWritten,\n            contentType: fileMeta.contentType ?? item.file.type,\n            createdAt: fileMeta.createdAt,\n            filename: fileMeta.originalName ?? item.file.name,\n            id: fileMeta.id ?? item.id,\n            metadata: fileMeta.metadata,\n            name: fileMeta.name,\n            originalName: fileMeta.originalName ?? item.file.name,\n            size: fileMeta.size ?? item.file.size,\n            status: fileMeta.status ?? \"completed\",\n            url: item.url\n          };\n          resolved = true;\n          cleanup();\n          resolve(uploadResult);\n        }\n      };\n      const onError = (item) => {\n        if (!resolved && item.file.name === file.name) {\n          const error = new Error(item.error || \"Upload failed\");\n          resolved = true;\n          cleanup();\n          reject(error);\n        }\n      };\n      uploader.on(\"ITEM_FINISH\", onItemFinish);\n      uploader.on(\"ITEM_ERROR\", onError);\n      uploader.add(file);\n      let timeoutId;\n      const originalCleanup = cleanup;\n      const cleanupWithTimeout = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = void 0;\n        }\n        originalCleanup();\n      };\n      timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          cleanupWithTimeout();\n          reject(new Error(\"Upload timeout\"));\n        }\n      }, 3e5);\n      const originalOnItemFinish = onItemFinish;\n      const originalOnError = onError;\n      uploader.off(\"ITEM_FINISH\", onItemFinish);\n      uploader.off(\"ITEM_ERROR\", onError);\n      uploader.on(\"ITEM_FINISH\", (item) => {\n        originalOnItemFinish(item);\n        cleanupWithTimeout();\n      });\n      uploader.on(\"ITEM_ERROR\", (item) => {\n        originalOnError(item);\n        cleanupWithTimeout();\n      });\n    }),\n    uploader\n  };\n};\n\nexport { createMultipartAdapter };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,yBAAyB,CAAC;IAC9B,MAAM,WAAW,IAAA,sMAAc,EAAC;QAC9B,UAAU,QAAQ,QAAQ;QAC1B,YAAY,QAAQ,UAAU;QAC9B,UAAU,QAAQ,QAAQ;QAC1B,OAAO,QAAQ,KAAK;IACtB;IACA,OAAO;QACL;;KAEC,GACD,OAAO;YACL,SAAS,KAAK;QAChB;QACA;;KAEC,GACD,OAAO;YACL,SAAS,KAAK;QAChB;QACA;;KAEC,GACD,QAAQ,OAAO,OAAS,IAAI,QAAQ,CAAC,SAAS;gBAC5C,IAAI;gBACJ,IAAI,WAAW;gBACf,MAAM,UAAU;oBACd,SAAS,GAAG,CAAC,eAAe;oBAC5B,SAAS,GAAG,CAAC,cAAc;gBAC7B;gBACA,MAAM,eAAe,CAAC;oBACpB,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,EAAE;wBAC7C,IAAI,WAAW,CAAC;wBAChB,IAAI;4BACF,IAAI,KAAK,cAAc,EAAE,QAAQ,OAAO,KAAK,cAAc,CAAC,IAAI,KAAK,UAAU;gCAC7E,WAAW,KAAK,cAAc,CAAC,IAAI;4BACrC,OAAO,IAAI,KAAK,cAAc,EAAE,UAAU;gCACxC,WAAW,KAAK,KAAK,CAAC,KAAK,cAAc,CAAC,QAAQ;4BACpD;wBACF,EAAE,OAAM,CACR;wBACA,eAAe;4BACb,cAAc,SAAS,YAAY;4BACnC,aAAa,SAAS,WAAW,IAAI,KAAK,IAAI,CAAC,IAAI;4BACnD,WAAW,SAAS,SAAS;4BAC7B,UAAU,SAAS,YAAY,IAAI,KAAK,IAAI,CAAC,IAAI;4BACjD,IAAI,SAAS,EAAE,IAAI,KAAK,EAAE;4BAC1B,UAAU,SAAS,QAAQ;4BAC3B,MAAM,SAAS,IAAI;4BACnB,cAAc,SAAS,YAAY,IAAI,KAAK,IAAI,CAAC,IAAI;4BACrD,MAAM,SAAS,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI;4BACrC,QAAQ,SAAS,MAAM,IAAI;4BAC3B,KAAK,KAAK,GAAG;wBACf;wBACA,WAAW;wBACX;wBACA,QAAQ;oBACV;gBACF;gBACA,MAAM,UAAU,CAAC;oBACf,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,EAAE;wBAC7C,MAAM,QAAQ,IAAI,MAAM,KAAK,KAAK,IAAI;wBACtC,WAAW;wBACX;wBACA,OAAO;oBACT;gBACF;gBACA,SAAS,EAAE,CAAC,eAAe;gBAC3B,SAAS,EAAE,CAAC,cAAc;gBAC1B,SAAS,GAAG,CAAC;gBACb,IAAI;gBACJ,MAAM,kBAAkB;gBACxB,MAAM,qBAAqB;oBACzB,IAAI,WAAW;wBACb,aAAa;wBACb,YAAY,KAAK;oBACnB;oBACA;gBACF;gBACA,YAAY,WAAW;oBACrB,IAAI,CAAC,UAAU;wBACb,WAAW;wBACX;wBACA,OAAO,IAAI,MAAM;oBACnB;gBACF,GAAG;gBACH,MAAM,uBAAuB;gBAC7B,MAAM,kBAAkB;gBACxB,SAAS,GAAG,CAAC,eAAe;gBAC5B,SAAS,GAAG,CAAC,cAAc;gBAC3B,SAAS,EAAE,CAAC,eAAe,CAAC;oBAC1B,qBAAqB;oBACrB;gBACF;gBACA,SAAS,EAAE,CAAC,cAAc,CAAC;oBACzB,gBAAgB;oBAChB;gBACF;YACF;QACA;IACF;AACF"}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/useMultipartUpload-CHknrlMk.js"],"sourcesContent":["import { useMemo, useState, useRef, useEffect } from 'react';\nimport { createMultipartAdapter } from './createMultipartAdapter-zOB0rL96.js';\n\nconst useMultipartUpload = (options) => {\n  const { endpoint, metadata, onError, onProgress, onStart, onSuccess } = options;\n  const uploaderInstance = useMemo(\n    () => createMultipartAdapter({\n      endpoint,\n      metadata\n    }),\n    [endpoint, metadata]\n  );\n  const [progress, setProgress] = useState(0);\n  const [isUploading, setIsUploading] = useState(false);\n  const [error, setError] = useState(void 0);\n  const [result, setResult] = useState(void 0);\n  const currentItemRef = useRef(void 0);\n  const currentFileRef = useRef(void 0);\n  const callbacksRef = useRef({ onError, onProgress, onStart, onSuccess });\n  useEffect(() => {\n    callbacksRef.current = { onError, onProgress, onStart, onSuccess };\n  }, [onError, onProgress, onStart, onSuccess]);\n  useEffect(() => {\n    const { uploader } = uploaderInstance;\n    const onItemProgress = (item) => {\n      if (item.id === currentItemRef.current) {\n        const progressValue = Math.min(100, Math.max(0, item.completed));\n        setProgress(progressValue);\n        callbacksRef.current.onProgress?.(progressValue);\n      }\n    };\n    const onItemStart = (item) => {\n      currentItemRef.current = item.id;\n      currentFileRef.current = item.file;\n      setIsUploading(true);\n      setProgress(0);\n      setError(void 0);\n      callbacksRef.current.onStart?.();\n    };\n    const onItemFinish = (item) => {\n      if (item.id === currentItemRef.current) {\n        let fileMeta = {};\n        try {\n          if (item.uploadResponse?.data && typeof item.uploadResponse.data === \"object\") {\n            fileMeta = item.uploadResponse.data;\n          } else if (item.uploadResponse?.response) {\n            fileMeta = JSON.parse(item.uploadResponse.response);\n          }\n        } catch {\n        }\n        const uploadResult = {\n          bytesWritten: fileMeta.bytesWritten,\n          contentType: fileMeta.contentType ?? item.file.type,\n          createdAt: fileMeta.createdAt,\n          filename: fileMeta.originalName ?? item.file.name,\n          id: fileMeta.id ?? item.id,\n          metadata: fileMeta.metadata,\n          name: fileMeta.name,\n          originalName: fileMeta.originalName ?? item.file.name,\n          size: fileMeta.size ?? item.file.size,\n          status: fileMeta.status ?? \"completed\",\n          url: item.url\n        };\n        setProgress(100);\n        setResult(uploadResult);\n        setIsUploading(false);\n        callbacksRef.current.onSuccess?.(uploadResult);\n        currentItemRef.current = void 0;\n        currentFileRef.current = void 0;\n      }\n    };\n    const onUploadError = (item) => {\n      if (item.id === currentItemRef.current) {\n        const uploadError = new Error(item.error || \"Upload failed\");\n        setError(uploadError);\n        setIsUploading(false);\n        callbacksRef.current.onError?.(uploadError);\n        currentItemRef.current = void 0;\n      }\n    };\n    uploader.on(\"ITEM_START\", onItemStart);\n    uploader.on(\"ITEM_PROGRESS\", onItemProgress);\n    uploader.on(\"ITEM_FINISH\", onItemFinish);\n    uploader.on(\"ITEM_ERROR\", onUploadError);\n    return () => {\n      uploader.off(\"ITEM_START\", onItemStart);\n      uploader.off(\"ITEM_PROGRESS\", onItemProgress);\n      uploader.off(\"ITEM_FINISH\", onItemFinish);\n      uploader.off(\"ITEM_ERROR\", onUploadError);\n    };\n  }, [uploaderInstance]);\n  const upload = async (file) => {\n    try {\n      return await uploaderInstance.upload(file);\n    } catch (error_) {\n      const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n      setError(uploadError);\n      callbacksRef.current.onError?.(uploadError);\n      throw uploadError;\n    }\n  };\n  const reset = () => {\n    uploaderInstance.clear();\n    setProgress(0);\n    setIsUploading(false);\n    setError(void 0);\n    setResult(void 0);\n    currentItemRef.current = void 0;\n  };\n  return {\n    error,\n    isUploading,\n    progress,\n    reset,\n    result,\n    upload\n  };\n};\n\nexport { useMultipartUpload };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 946, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/createTusAdapter-DnKwZsIz.js"],"sourcesContent":["const TUS_RESUMABLE_VERSION = \"1.0.0\";\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024;\nconst encodeMetadata = (metadata) => Object.entries(metadata).map(([key, value]) => {\n  const encoded = btoa(unescape(encodeURIComponent(value)));\n  return `${key} ${encoded}`;\n}).join(\",\");\nconst decodeMetadata = (header) => {\n  if (!header) {\n    return {};\n  }\n  const metadata = {};\n  header.split(\",\").forEach((item) => {\n    const [key, ...valueParts] = item.trim().split(\" \");\n    const encoded = valueParts.join(\" \");\n    if (key && encoded) {\n      try {\n        metadata[key] = decodeURIComponent(escape(atob(encoded)));\n      } catch {\n      }\n    }\n  });\n  return metadata;\n};\nconst createTusAdapter = (options) => {\n  const { chunkSize = DEFAULT_CHUNK_SIZE, endpoint, maxRetries = 3, metadata = {}, retry = true } = options;\n  let uploadState = null;\n  let progressCallback;\n  let startCallback;\n  let finishCallback;\n  let errorCallback;\n  const createUpload = async (file) => {\n    const fileMetadata = {\n      filename: file.name,\n      filetype: file.type,\n      ...metadata\n    };\n    const response = await fetch(endpoint, {\n      headers: {\n        \"Tus-Resumable\": TUS_RESUMABLE_VERSION,\n        \"Upload-Length\": file.size.toString(),\n        \"Upload-Metadata\": encodeMetadata(fileMetadata)\n      },\n      method: \"POST\"\n    });\n    if (response.status !== 201 && response.status !== 200) {\n      throw new Error(`Failed to create upload: ${response.status} ${response.statusText}`);\n    }\n    const location = response.headers.get(\"Location\");\n    if (!location) {\n      throw new Error(\"No Location header in response\");\n    }\n    let uploadUrl;\n    if (location.startsWith(\"http\")) {\n      uploadUrl = location;\n    } else {\n      try {\n        uploadUrl = new URL(location, endpoint).href;\n      } catch {\n        const baseUrl = globalThis.window === void 0 ? \"http://localhost\" : globalThis.location.origin;\n        uploadUrl = new URL(location, baseUrl + endpoint).href;\n      }\n    }\n    const initialOffsetHeader = response.headers.get(\"Upload-Offset\");\n    const initialOffset = initialOffsetHeader ? Number.parseInt(initialOffsetHeader, 10) : 0;\n    return { initialOffset, uploadUrl };\n  };\n  const getUploadOffset = async (uploadUrl) => {\n    const response = await fetch(uploadUrl, {\n      headers: {\n        \"Tus-Resumable\": TUS_RESUMABLE_VERSION\n      },\n      method: \"HEAD\"\n    });\n    if (!response.ok) {\n      if (response.status === 404 || response.status === 410 || response.status === 403) {\n        return 0;\n      }\n      throw new Error(`Failed to get upload offset: ${response.status} ${response.statusText}`);\n    }\n    const offsetHeader = response.headers.get(\"Upload-Offset\");\n    return offsetHeader ? Number.parseInt(offsetHeader, 10) : 0;\n  };\n  const uploadChunk = async (file, uploadUrl, startOffset, signal) => {\n    const endOffset = Math.min(startOffset + chunkSize, file.size);\n    const chunk = file.slice(startOffset, endOffset);\n    const response = await fetch(uploadUrl, {\n      body: chunk,\n      headers: {\n        \"Content-Length\": chunk.size.toString(),\n        // Explicitly set Content-Length as required by TUS protocol\n        \"Content-Type\": \"application/offset+octet-stream\",\n        \"Tus-Resumable\": TUS_RESUMABLE_VERSION,\n        \"Upload-Offset\": startOffset.toString()\n      },\n      method: \"PATCH\",\n      signal\n    });\n    if (response.status !== 204) {\n      if (response.status === 409) {\n        const currentOffset = await getUploadOffset(uploadUrl);\n        return currentOffset;\n      }\n      if (response.status === 404 || response.status === 410) {\n        throw new Error(\"Upload expired or not found\");\n      }\n      if (response.status === 415) {\n        throw new Error(\"Content-Type must be application/offset+octet-stream\");\n      }\n      throw new Error(`Failed to upload chunk: ${response.status} ${response.statusText}`);\n    }\n    const newOffsetHeader = response.headers.get(\"Upload-Offset\");\n    if (!newOffsetHeader) {\n      throw new Error(\"Missing Upload-Offset header in PATCH response\");\n    }\n    return Number.parseInt(newOffsetHeader, 10);\n  };\n  const performUpload = async (file, uploadUrl, startOffset = 0) => {\n    if (!uploadState) {\n      throw new Error(\"Upload state not initialized\");\n    }\n    let currentOffset = startOffset;\n    while (currentOffset < file.size) {\n      if (uploadState.isPaused) {\n        await new Promise((resolve) => {\n          const checkPause = () => {\n            if (uploadState?.isPaused) {\n              setTimeout(checkPause, 100);\n            } else {\n              resolve();\n            }\n          };\n          checkPause();\n        });\n      }\n      if (uploadState.abortController.signal.aborted) {\n        throw new Error(\"Upload aborted\");\n      }\n      try {\n        currentOffset = await uploadChunk(file, uploadUrl, currentOffset, uploadState.abortController.signal);\n        uploadState.offset = currentOffset;\n        const progressPercent = Math.round(currentOffset / file.size * 100);\n        progressCallback?.(progressPercent, currentOffset);\n      } catch (error_) {\n        if (retry && uploadState.retryCount < maxRetries) {\n          uploadState.retryCount += 1;\n          await new Promise((resolve) => setTimeout(resolve, 1e3 * uploadState.retryCount));\n          currentOffset = await getUploadOffset(uploadUrl);\n          continue;\n        }\n        throw error_;\n      }\n      uploadState.retryCount = 0;\n    }\n    const headResponse = await fetch(uploadUrl, {\n      headers: {\n        \"Tus-Resumable\": TUS_RESUMABLE_VERSION\n      },\n      method: \"HEAD\"\n    });\n    const location = headResponse.headers.get(\"Location\") || uploadUrl;\n    const uploadMetadata = decodeMetadata(headResponse.headers.get(\"Upload-Metadata\"));\n    let fileMeta = {};\n    try {\n      const contentType = headResponse.headers.get(\"Content-Type\") || uploadMetadata.filetype || file.type;\n      fileMeta = {\n        contentType,\n        id: uploadUrl.split(\"/\").pop() || \"\",\n        metadata: uploadMetadata,\n        originalName: uploadMetadata.filename || file.name,\n        size: file.size,\n        status: \"completed\"\n      };\n    } catch {\n    }\n    return {\n      bytesWritten: currentOffset,\n      contentType: fileMeta.contentType ?? file.type,\n      createdAt: fileMeta.createdAt,\n      filename: fileMeta.originalName ?? file.name,\n      id: fileMeta.id ?? uploadUrl.split(\"/\").pop() ?? \"\",\n      metadata: fileMeta.metadata ?? uploadMetadata,\n      name: fileMeta.name,\n      offset: currentOffset,\n      originalName: fileMeta.originalName ?? file.name,\n      size: fileMeta.size ?? file.size,\n      status: fileMeta.status ?? \"completed\",\n      url: location\n    };\n  };\n  return {\n    /**\n     * Abort the current upload\n     */\n    abort: () => {\n      if (uploadState) {\n        uploadState.abortController.abort();\n        uploadState = null;\n      }\n    },\n    /**\n     * Clear all uploads\n     */\n    clear: () => {\n      if (uploadState) {\n        uploadState.abortController.abort();\n        uploadState = null;\n      }\n    },\n    /**\n     * Get current upload offset\n     */\n    getOffset: () => uploadState?.offset ?? 0,\n    /**\n     * Whether upload is paused\n     */\n    isPaused: () => uploadState?.isPaused ?? false,\n    /**\n     * Pause the current upload\n     */\n    pause: () => {\n      if (uploadState) {\n        uploadState.isPaused = true;\n      }\n    },\n    /**\n     * Resume a paused upload\n     */\n    resume: async () => {\n      if (!uploadState || !uploadState.uploadUrl) {\n        throw new Error(\"No upload to resume\");\n      }\n      uploadState.isPaused = false;\n      try {\n        const currentOffset = await getUploadOffset(uploadState.uploadUrl);\n        uploadState.offset = currentOffset;\n        progressCallback?.(Math.round(currentOffset / uploadState.file.size * 100), currentOffset);\n        const uploadResult = await performUpload(uploadState.file, uploadState.uploadUrl, currentOffset);\n        finishCallback?.(uploadResult);\n      } catch (error_) {\n        const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n        errorCallback?.(uploadError);\n        throw uploadError;\n      }\n    },\n    /**\n     * Set error callback\n     */\n    setOnError: (callback) => {\n      errorCallback = callback;\n    },\n    /**\n     * Set finish callback\n     */\n    setOnFinish: (callback) => {\n      finishCallback = callback;\n    },\n    /**\n     * Set progress callback\n     */\n    setOnProgress: (callback) => {\n      progressCallback = callback;\n    },\n    /**\n     * Set start callback\n     */\n    setOnStart: (callback) => {\n      startCallback = callback;\n    },\n    /**\n     * Upload a file and return visulima-compatible result\n     */\n    upload: async (file) => new Promise((resolve, reject) => {\n      let resolved = false;\n      const originalFinishCallback = finishCallback;\n      const originalErrorCallback = errorCallback;\n      let timeoutId;\n      const cleanupTimeout = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = void 0;\n        }\n        finishCallback = originalFinishCallback;\n        errorCallback = originalErrorCallback;\n      };\n      const internalFinishCallback = (result) => {\n        if (!resolved) {\n          resolved = true;\n          cleanupTimeout();\n          originalFinishCallback?.(result);\n          uploadState = null;\n          resolve(result);\n        }\n      };\n      const internalErrorCallback = (error) => {\n        if (!resolved) {\n          resolved = true;\n          cleanupTimeout();\n          originalErrorCallback?.(error);\n          if (!retry || uploadState && uploadState.retryCount >= maxRetries) {\n            uploadState = null;\n          }\n          reject(error);\n        }\n      };\n      finishCallback = internalFinishCallback;\n      errorCallback = internalErrorCallback;\n      uploadState = {\n        abortController: new AbortController(),\n        file,\n        isPaused: false,\n        offset: 0,\n        retryCount: 0,\n        uploadUrl: null\n      };\n      (async () => {\n        try {\n          startCallback?.();\n          let uploadUrl = uploadState?.uploadUrl;\n          if (uploadUrl) {\n            const currentOffset = await getUploadOffset(uploadUrl);\n            if (currentOffset > 0 && uploadState) {\n              uploadState.offset = currentOffset;\n              progressCallback?.(Math.round(currentOffset / file.size * 100), currentOffset);\n            }\n          } else {\n            const { initialOffset, uploadUrl: newUploadUrl } = await createUpload(file);\n            uploadUrl = newUploadUrl;\n            if (uploadState) {\n              uploadState.uploadUrl = uploadUrl;\n              uploadState.offset = initialOffset;\n              if (initialOffset > 0) {\n                progressCallback?.(Math.round(initialOffset / file.size * 100), initialOffset);\n              }\n            }\n          }\n          if (!uploadState) {\n            throw new Error(\"Upload state lost\");\n          }\n          const uploadResult = await performUpload(file, uploadUrl, uploadState.offset);\n          finishCallback(uploadResult);\n        } catch (error_) {\n          errorCallback(error_ instanceof Error ? error_ : new Error(String(error_)));\n        }\n      })();\n      timeoutId = setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          cleanupTimeout();\n          uploadState = null;\n          reject(new Error(\"Upload timeout\"));\n        }\n      }, 3e5);\n    })\n  };\n};\n\nexport { createTusAdapter };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1300, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/useTusUpload-5J-n5an0.js"],"sourcesContent":["import { useState, useMemo, useRef, useEffect, useCallback } from 'react';\nimport { createTusAdapter } from './createTusAdapter-DnKwZsIz.js';\n\nconst useTusUpload = (options) => {\n  const { chunkSize, endpoint, maxRetries, metadata, onError, onPause, onProgress, onResume, onStart, onSuccess, retry } = options;\n  const [progress, setProgress] = useState(0);\n  const [isUploading, setIsUploading] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [error, setError] = useState(null);\n  const [result, setResult] = useState(null);\n  const [offset, setOffset] = useState(0);\n  const adapterInstance = useMemo(\n    () => createTusAdapter({\n      chunkSize,\n      endpoint,\n      maxRetries,\n      metadata,\n      retry\n    }),\n    [chunkSize, endpoint, maxRetries, metadata, retry]\n  );\n  const callbacksRef = useRef({ onError, onPause, onProgress, onResume, onStart, onSuccess });\n  useEffect(() => {\n    callbacksRef.current = { onError, onPause, onProgress, onResume, onStart, onSuccess };\n  }, [onError, onProgress, onPause, onResume, onStart, onSuccess]);\n  useEffect(() => {\n    adapterInstance.setOnStart(() => {\n      setIsUploading(true);\n      setIsPaused(false);\n      setProgress(0);\n      setError(null);\n      setOffset(0);\n      callbacksRef.current.onStart?.();\n    });\n    adapterInstance.setOnProgress((progressValue, offsetValue) => {\n      setProgress(progressValue);\n      setOffset(offsetValue);\n      callbacksRef.current.onProgress?.(progressValue);\n    });\n    adapterInstance.setOnFinish((uploadResult) => {\n      setProgress(100);\n      setResult(uploadResult);\n      setIsUploading(false);\n      setIsPaused(false);\n      callbacksRef.current.onSuccess?.(uploadResult);\n    });\n    adapterInstance.setOnError((uploadError) => {\n      setError(uploadError);\n      setIsUploading(false);\n      callbacksRef.current.onError?.(uploadError);\n    });\n    const checkInterval = setInterval(() => {\n      setOffset(adapterInstance.getOffset());\n      setIsPaused(adapterInstance.isPaused());\n    }, 100);\n    return () => {\n      clearInterval(checkInterval);\n      adapterInstance.setOnStart(void 0);\n      adapterInstance.setOnProgress(void 0);\n      adapterInstance.setOnFinish(void 0);\n      adapterInstance.setOnError(void 0);\n    };\n  }, [adapterInstance]);\n  const upload = useCallback(\n    async (file) => {\n      try {\n        return await adapterInstance.upload(file);\n      } catch (error_) {\n        const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n        setError(uploadError);\n        callbacksRef.current.onError?.(uploadError);\n        throw uploadError;\n      }\n    },\n    [adapterInstance]\n  );\n  const pause = useCallback(() => {\n    adapterInstance.pause();\n    setIsPaused(true);\n    callbacksRef.current.onPause?.();\n  }, [adapterInstance]);\n  const resume = useCallback(async () => {\n    setIsPaused(false);\n    setIsUploading(true);\n    callbacksRef.current.onResume?.();\n    try {\n      await adapterInstance.resume();\n    } catch (error_) {\n      const uploadError = error_ instanceof Error ? error_ : new Error(String(error_));\n      setError(uploadError);\n      setIsUploading(false);\n      callbacksRef.current.onError?.(uploadError);\n      throw uploadError;\n    }\n  }, [adapterInstance]);\n  const abort = useCallback(() => {\n    adapterInstance.abort();\n    setIsUploading(false);\n    setIsPaused(false);\n  }, [adapterInstance]);\n  const reset = useCallback(() => {\n    adapterInstance.clear();\n    setProgress(0);\n    setIsUploading(false);\n    setIsPaused(false);\n    setError(null);\n    setResult(null);\n    setOffset(0);\n  }, [adapterInstance]);\n  return {\n    abort,\n    error,\n    isPaused,\n    isUploading,\n    offset,\n    pause,\n    progress,\n    reset,\n    result,\n    resume,\n    upload\n  };\n};\n\nexport { useTusUpload };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1466, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/dist/packem_shared/useUpload-n6uUGeUZ.js"],"sourcesContent":["import { useMemo, useCallback } from 'react';\nimport { useChunkedRestUpload } from './useChunkedRestUpload-DOPSk-t6.js';\nimport { useMultipartUpload } from './useMultipartUpload-CHknrlMk.js';\nimport { useTusUpload } from './useTusUpload-5J-n5an0.js';\n\nconst DEFAULT_TUS_THRESHOLD = 10 * 1024 * 1024;\nconst useUpload = (options) => {\n  const {\n    chunkSize,\n    endpointChunkedRest,\n    endpointMultipart,\n    endpointTus,\n    maxRetries,\n    metadata,\n    method,\n    onError,\n    onPause,\n    onProgress,\n    onResume,\n    onStart,\n    onSuccess,\n    retry,\n    tusThreshold = DEFAULT_TUS_THRESHOLD\n  } = options;\n  const detectedMethod = useMemo(() => {\n    if (method !== void 0) {\n      return method;\n    }\n    const endpoints = [endpointChunkedRest, endpointMultipart, endpointTus].filter(Boolean);\n    if (endpoints.length === 1) {\n      if (endpointChunkedRest) {\n        return \"chunked-rest\";\n      }\n      if (endpointTus) {\n        return \"tus\";\n      }\n      return \"multipart\";\n    }\n    if (endpoints.length > 1) {\n      return \"auto\";\n    }\n    throw new Error(\"At least one endpoint must be provided: endpointChunkedRest, endpointMultipart, or endpointTus\");\n  }, [method, endpointChunkedRest, endpointMultipart, endpointTus]);\n  const chunkedRestOptions = useMemo(() => {\n    if (!endpointChunkedRest) {\n      return void 0;\n    }\n    return {\n      chunkSize,\n      endpoint: endpointChunkedRest,\n      maxRetries,\n      metadata,\n      onError,\n      onPause,\n      onProgress,\n      onResume,\n      onStart,\n      onSuccess,\n      retry\n    };\n  }, [endpointChunkedRest, chunkSize, metadata, onStart, onSuccess, onError, onProgress, onPause, onResume, retry, maxRetries]);\n  const multipartOptions = useMemo(() => {\n    if (!endpointMultipart) {\n      return void 0;\n    }\n    return {\n      endpoint: endpointMultipart,\n      metadata,\n      onError,\n      onProgress,\n      onStart,\n      onSuccess\n    };\n  }, [endpointMultipart, metadata, onStart, onSuccess, onError, onProgress]);\n  const tusOptions = useMemo(() => {\n    if (!endpointTus) {\n      return void 0;\n    }\n    return {\n      chunkSize,\n      endpoint: endpointTus,\n      maxRetries,\n      metadata,\n      onError,\n      onPause,\n      onProgress,\n      onResume,\n      onStart,\n      onSuccess,\n      retry\n    };\n  }, [endpointTus, chunkSize, metadata, onStart, onSuccess, onError, onProgress, onPause, onResume, retry, maxRetries]);\n  const chunkedRestUpload = chunkedRestOptions ? useChunkedRestUpload(chunkedRestOptions) : null;\n  const multipartUpload = multipartOptions ? useMultipartUpload(multipartOptions) : null;\n  const tusUpload = tusOptions ? useTusUpload(tusOptions) : null;\n  const determineMethod = useCallback(\n    (file) => {\n      if (detectedMethod !== \"auto\") {\n        return detectedMethod;\n      }\n      if (file.size > tusThreshold) {\n        if (endpointTus) {\n          return \"tus\";\n        }\n        if (endpointChunkedRest) {\n          return \"chunked-rest\";\n        }\n      }\n      if (endpointChunkedRest) {\n        return \"chunked-rest\";\n      }\n      if (endpointMultipart) {\n        return \"multipart\";\n      }\n      throw new Error(\"No available endpoint for upload\");\n    },\n    [detectedMethod, tusThreshold, endpointChunkedRest, endpointMultipart, endpointTus]\n  );\n  const upload = useCallback(\n    async (file) => {\n      const selectedMethod = determineMethod(file);\n      if (selectedMethod === \"tus\") {\n        if (!tusUpload) {\n          throw new Error(\"TUS endpoint not configured\");\n        }\n        return tusUpload.upload(file);\n      }\n      if (selectedMethod === \"chunked-rest\") {\n        if (!chunkedRestUpload) {\n          throw new Error(\"Chunked REST endpoint not configured\");\n        }\n        return chunkedRestUpload.upload(file);\n      }\n      if (!multipartUpload) {\n        throw new Error(\"Multipart endpoint not configured\");\n      }\n      return multipartUpload.upload(file);\n    },\n    [determineMethod, tusUpload, chunkedRestUpload, multipartUpload]\n  );\n  const abort = useCallback(() => {\n    tusUpload?.abort();\n    chunkedRestUpload?.abort();\n    multipartUpload?.reset();\n  }, [tusUpload, chunkedRestUpload, multipartUpload]);\n  const reset = useCallback(() => {\n    tusUpload?.reset();\n    chunkedRestUpload?.reset();\n    multipartUpload?.reset();\n  }, [tusUpload, chunkedRestUpload, multipartUpload]);\n  const currentMethod = useMemo(() => {\n    if (detectedMethod !== \"auto\") {\n      return detectedMethod;\n    }\n    if (tusUpload && (tusUpload.isUploading || tusUpload.result)) {\n      return \"tus\";\n    }\n    if (chunkedRestUpload && (chunkedRestUpload.isUploading || chunkedRestUpload.result)) {\n      return \"chunked-rest\";\n    }\n    if (multipartUpload && (multipartUpload.isUploading || multipartUpload.result)) {\n      return \"multipart\";\n    }\n    if (endpointChunkedRest) {\n      return \"chunked-rest\";\n    }\n    if (endpointTus) {\n      return \"tus\";\n    }\n    return \"multipart\";\n  }, [detectedMethod, tusUpload, chunkedRestUpload, multipartUpload, endpointChunkedRest, endpointMultipart, endpointTus]);\n  return {\n    abort,\n    currentMethod,\n    error: currentMethod === \"tus\" ? tusUpload?.error ?? null : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.error ?? null : multipartUpload?.error ?? null,\n    isPaused: currentMethod === \"tus\" ? tusUpload?.isPaused : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.isPaused : void 0,\n    isUploading: currentMethod === \"tus\" ? tusUpload?.isUploading ?? false : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.isUploading ?? false : multipartUpload?.isUploading ?? false,\n    offset: currentMethod === \"tus\" ? tusUpload?.offset : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.offset : void 0,\n    pause: currentMethod === \"tus\" ? tusUpload?.pause : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.pause : void 0,\n    progress: currentMethod === \"tus\" ? tusUpload?.progress ?? 0 : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.progress ?? 0 : multipartUpload?.progress ?? 0,\n    reset,\n    result: currentMethod === \"tus\" ? tusUpload?.result ?? null : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.result ?? null : multipartUpload?.result ?? null,\n    resume: currentMethod === \"tus\" ? tusUpload?.resume : currentMethod === \"chunked-rest\" ? chunkedRestUpload?.resume : void 0,\n    upload\n  };\n};\n\nexport { useUpload };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1709, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/packages/storage-client/examples/nextjs/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useUpload } from \"@visulima/storage-client/react\";\nimport { useState } from \"react\";\n\nexport default function Home() {\n    const [file, setFile] = useState<File | null>(null);\n    const { error, isUploading, progress, result, upload } = useUpload({\n        endpointMultipart: \"/api/upload/multipart\",\n        endpointTus: \"/api/upload/tus\",\n        onError: (error) => {\n            console.error(\"Upload error:\", error);\n        },\n        onSuccess: (result) => {\n            console.log(\"Upload successful:\", result);\n        },\n    });\n\n    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const selectedFile = e.target.files?.[0];\n\n        setFile(selectedFile || null);\n    };\n\n    const handleUpload = async () => {\n        if (file) {\n            try {\n                await upload(file);\n            } catch (error_) {\n                console.error(\"Upload failed:\", error_);\n            }\n        }\n    };\n\n    return (\n        <main>\n            <h1>Storage Client - Next.js Example</h1>\n            <div style={{ marginTop: \"2rem\" }}>\n                <input disabled={isUploading} onChange={handleFileChange} type=\"file\" />\n                <button disabled={!file || isUploading} onClick={handleUpload} style={{ marginLeft: \"1rem\" }}>\n                    {isUploading ? \"Uploading...\" : \"Upload\"}\n                </button>\n            </div>\n            {isUploading && (\n                <div style={{ marginTop: \"1rem\" }}>\n                    <div>\n                        Progress:\n                        {progress}\n                        %\n                    </div>\n                    <progress max={100} value={progress} />\n                </div>\n            )}\n            {error && (\n                <div style={{ color: \"red\", marginTop: \"1rem\" }}>\n                    Error:\n                    {error.message}\n                </div>\n            )}\n            {result && (\n                <div style={{ color: \"green\", marginTop: \"1rem\" }}>\n                    Upload complete! File:\n                    {result.filename}\n                </div>\n            )}\n        </main>\n    );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAKe,SAAS;IACpB,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,+ZAAQ,EAAc;IAC9C,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,4LAAS,EAAC;QAC/D,mBAAmB;QACnB,aAAa;QACb,SAAS,CAAC;YACN,QAAQ,KAAK,CAAC,iBAAiB;QACnC;QACA,WAAW,CAAC;YACR,QAAQ,GAAG,CAAC,sBAAsB;QACtC;IACJ;IAEA,MAAM,mBAAmB,CAAC;QACtB,MAAM,eAAe,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE;QAExC,QAAQ,gBAAgB;IAC5B;IAEA,MAAM,eAAe;QACjB,IAAI,MAAM;YACN,IAAI;gBACA,MAAM,OAAO;YACjB,EAAE,OAAO,QAAQ;gBACb,QAAQ,KAAK,CAAC,kBAAkB;YACpC;QACJ;IACJ;IAEA,qBACI,4bAAC;;0BACG,4bAAC;0BAAG;;;;;;0BACJ,4bAAC;gBAAI,OAAO;oBAAE,WAAW;gBAAO;;kCAC5B,4bAAC;wBAAM,UAAU;wBAAa,UAAU;wBAAkB,MAAK;;;;;;kCAC/D,4bAAC;wBAAO,UAAU,CAAC,QAAQ;wBAAa,SAAS;wBAAc,OAAO;4BAAE,YAAY;wBAAO;kCACtF,cAAc,iBAAiB;;;;;;;;;;;;YAGvC,6BACG,4bAAC;gBAAI,OAAO;oBAAE,WAAW;gBAAO;;kCAC5B,4bAAC;;4BAAI;4BAEA;4BAAS;;;;;;;kCAGd,4bAAC;wBAAS,KAAK;wBAAK,OAAO;;;;;;;;;;;;YAGlC,uBACG,4bAAC;gBAAI,OAAO;oBAAE,OAAO;oBAAO,WAAW;gBAAO;;oBAAG;oBAE5C,MAAM,OAAO;;;;;;;YAGrB,wBACG,4bAAC;gBAAI,OAAO;oBAAE,OAAO;oBAAS,WAAW;gBAAO;;oBAAG;oBAE9C,OAAO,QAAQ;;;;;;;;;;;;;AAKpC"}},
    {"offset": {"line": 1855, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/node_modules/.pnpm/next%4016.0.3_%40opentelemetry%2Bapi%401.9.0_%40playwright%2Btest%401.56.1_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1874, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/node_modules/.pnpm/next%4016.0.3_%40opentelemetry%2Bapi%401.9.0_%40playwright%2Btest%401.56.1_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,wPACRC,QAAQ,CAAC,YAAY,CAAEC,kBAAkB","ignoreList":[0]}},
    {"offset": {"line": 1879, "column": 0}, "map": {"version":3,"sources":["file:///home/prisis/WebstormProjects/visulima/visulima/node_modules/.pnpm/next%4016.0.3_%40opentelemetry%2Bapi%401.9.0_%40playwright%2Btest%401.56.1_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,wPACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0]}}]
}