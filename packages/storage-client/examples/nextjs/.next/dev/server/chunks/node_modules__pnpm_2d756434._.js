module.exports = [
"[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}),
"[project]/node_modules/.pnpm/@borewit+text-codec@0.1.1/node_modules/@borewit/text-codec/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// text-polyfill.ts
// Minimal encode/decode for utf-8, utf-16le, ascii, latin1, windows-1252
__turbopack_context__.s([
    "textDecode",
    ()=>textDecode,
    "textEncode",
    ()=>textEncode
]);
const WINDOWS_1252_EXTRA = {
    0x80: "€",
    0x82: "‚",
    0x83: "ƒ",
    0x84: "„",
    0x85: "…",
    0x86: "†",
    0x87: "‡",
    0x88: "ˆ",
    0x89: "‰",
    0x8a: "Š",
    0x8b: "‹",
    0x8c: "Œ",
    0x8e: "Ž",
    0x91: "‘",
    0x92: "’",
    0x93: "“",
    0x94: "”",
    0x95: "•",
    0x96: "–",
    0x97: "—",
    0x98: "˜",
    0x99: "™",
    0x9a: "š",
    0x9b: "›",
    0x9c: "œ",
    0x9e: "ž",
    0x9f: "Ÿ"
};
const WINDOWS_1252_REVERSE = {};
for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)){
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
}
function textDecode(bytes, encoding = "utf-8") {
    switch(encoding.toLowerCase()){
        case "utf-8":
        case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
                return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8(bytes);
        case "utf-16le":
            return decodeUTF16LE(bytes);
        case "ascii":
            return decodeASCII(bytes);
        case "latin1":
        case "iso-8859-1":
            return decodeLatin1(bytes);
        case "windows-1252":
            return decodeWindows1252(bytes);
        default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
    }
}
function textEncode(input = "", encoding = "utf-8") {
    switch(encoding.toLowerCase()){
        case "utf-8":
        case "utf8":
            if (typeof globalThis.TextEncoder !== "undefined") {
                return new globalThis.TextEncoder().encode(input);
            }
            return encodeUTF8(input);
        case "utf-16le":
            return encodeUTF16LE(input);
        case "ascii":
            return encodeASCII(input);
        case "latin1":
        case "iso-8859-1":
            return encodeLatin1(input);
        case "windows-1252":
            return encodeWindows1252(input);
        default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
    }
}
// --- Internal helpers ---
function decodeUTF8(bytes) {
    let out = "";
    let i = 0;
    while(i < bytes.length){
        const b1 = bytes[i++];
        if (b1 < 0x80) {
            out += String.fromCharCode(b1);
        } else if (b1 < 0xe0) {
            const b2 = bytes[i++] & 0x3f;
            out += String.fromCharCode((b1 & 0x1f) << 6 | b2);
        } else if (b1 < 0xf0) {
            const b2 = bytes[i++] & 0x3f;
            const b3 = bytes[i++] & 0x3f;
            out += String.fromCharCode((b1 & 0x0f) << 12 | b2 << 6 | b3);
        } else {
            const b2 = bytes[i++] & 0x3f;
            const b3 = bytes[i++] & 0x3f;
            const b4 = bytes[i++] & 0x3f;
            let cp = (b1 & 0x07) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 0x10000;
            out += String.fromCharCode(0xd800 + (cp >> 10 & 0x3ff), 0xdc00 + (cp & 0x3ff));
        }
    }
    return out;
}
function decodeUTF16LE(bytes) {
    let out = "";
    for(let i = 0; i < bytes.length; i += 2){
        out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
    }
    return out;
}
function decodeASCII(bytes) {
    return String.fromCharCode(...bytes.map((b)=>b & 0x7f));
}
function decodeLatin1(bytes) {
    return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
    let out = "";
    for (const b of bytes){
        if (b >= 0x80 && b <= 0x9f && WINDOWS_1252_EXTRA[b]) {
            out += WINDOWS_1252_EXTRA[b];
        } else {
            out += String.fromCharCode(b);
        }
    }
    return out;
}
function encodeUTF8(str) {
    const out = [];
    for(let i = 0; i < str.length; i++){
        const cp = str.charCodeAt(i);
        if (cp < 0x80) {
            out.push(cp);
        } else if (cp < 0x800) {
            out.push(0xc0 | cp >> 6, 0x80 | cp & 0x3f);
        } else if (cp < 0x10000) {
            out.push(0xe0 | cp >> 12, 0x80 | cp >> 6 & 0x3f, 0x80 | cp & 0x3f);
        } else {
            out.push(0xf0 | cp >> 18, 0x80 | cp >> 12 & 0x3f, 0x80 | cp >> 6 & 0x3f, 0x80 | cp & 0x3f);
        }
    }
    return new Uint8Array(out);
}
function encodeUTF16LE(str) {
    const out = new Uint8Array(str.length * 2);
    for(let i = 0; i < str.length; i++){
        const code = str.charCodeAt(i);
        out[i * 2] = code & 0xff;
        out[i * 2 + 1] = code >> 8;
    }
    return out;
}
function encodeASCII(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>ch.charCodeAt(0) & 0x7f));
}
function encodeLatin1(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>ch.charCodeAt(0) & 0xff));
}
function encodeWindows1252(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>{
        const code = ch.charCodeAt(0);
        if (code <= 0xff) return code;
        if (WINDOWS_1252_REVERSE[ch] !== undefined) return WINDOWS_1252_REVERSE[ch];
        return 0x3f; // '?'
    }));
}
}),
"[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AnsiStringType",
    ()=>AnsiStringType,
    "Float16_BE",
    ()=>Float16_BE,
    "Float16_LE",
    ()=>Float16_LE,
    "Float32_BE",
    ()=>Float32_BE,
    "Float32_LE",
    ()=>Float32_LE,
    "Float64_BE",
    ()=>Float64_BE,
    "Float64_LE",
    ()=>Float64_LE,
    "Float80_BE",
    ()=>Float80_BE,
    "Float80_LE",
    ()=>Float80_LE,
    "INT16_BE",
    ()=>INT16_BE,
    "INT16_LE",
    ()=>INT16_LE,
    "INT24_BE",
    ()=>INT24_BE,
    "INT24_LE",
    ()=>INT24_LE,
    "INT32_BE",
    ()=>INT32_BE,
    "INT32_LE",
    ()=>INT32_LE,
    "INT64_BE",
    ()=>INT64_BE,
    "INT64_LE",
    ()=>INT64_LE,
    "INT8",
    ()=>INT8,
    "IgnoreType",
    ()=>IgnoreType,
    "StringType",
    ()=>StringType,
    "UINT16_BE",
    ()=>UINT16_BE,
    "UINT16_LE",
    ()=>UINT16_LE,
    "UINT24_BE",
    ()=>UINT24_BE,
    "UINT24_LE",
    ()=>UINT24_LE,
    "UINT32_BE",
    ()=>UINT32_BE,
    "UINT32_LE",
    ()=>UINT32_LE,
    "UINT64_BE",
    ()=>UINT64_BE,
    "UINT64_LE",
    ()=>UINT64_LE,
    "UINT8",
    ()=>UINT8,
    "Uint8ArrayType",
    ()=>Uint8ArrayType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$borewit$2b$text$2d$codec$40$0$2e$1$2e$1$2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@borewit+text-codec@0.1.1/node_modules/@borewit/text-codec/lib/index.js [app-route] (ecmascript)");
;
;
// Primitive types
function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
}
const UINT8 = {
    len: 1,
    get (array, offset) {
        return dv(array).getUint8(offset);
    },
    put (array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
    }
};
const UINT16_LE = {
    len: 2,
    get (array, offset) {
        return dv(array).getUint16(offset, true);
    },
    put (array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
    }
};
const UINT16_BE = {
    len: 2,
    get (array, offset) {
        return dv(array).getUint16(offset);
    },
    put (array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
    }
};
const UINT24_LE = {
    len: 3,
    get (array, offset) {
        const dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const UINT24_BE = {
    len: 3,
    get (array, offset) {
        const dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const UINT32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getUint32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
    }
};
const UINT32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getUint32(offset);
    },
    put (array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
    }
};
const INT8 = {
    len: 1,
    get (array, offset) {
        return dv(array).getInt8(offset);
    },
    put (array, offset, value) {
        dv(array).setInt8(offset, value);
        return offset + 1;
    }
};
const INT16_BE = {
    len: 2,
    get (array, offset) {
        return dv(array).getInt16(offset);
    },
    put (array, offset, value) {
        dv(array).setInt16(offset, value);
        return offset + 2;
    }
};
const INT16_LE = {
    len: 2,
    get (array, offset) {
        return dv(array).getInt16(offset, true);
    },
    put (array, offset, value) {
        dv(array).setInt16(offset, value, true);
        return offset + 2;
    }
};
const INT24_LE = {
    len: 3,
    get (array, offset) {
        const unsigned = UINT24_LE.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const INT24_BE = {
    len: 3,
    get (array, offset) {
        const unsigned = UINT24_BE.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const INT32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getInt32(offset);
    },
    put (array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
    }
};
const INT32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getInt32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setInt32(offset, value, true);
        return offset + 4;
    }
};
const UINT64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigUint64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
    }
};
const INT64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigInt64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setBigInt64(offset, value, true);
        return offset + 8;
    }
};
const UINT64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigUint64(offset);
    },
    put (array, offset, value) {
        dv(array).setBigUint64(offset, value);
        return offset + 8;
    }
};
const INT64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigInt64(offset);
    },
    put (array, offset, value) {
        dv(array).setBigInt64(offset, value);
        return offset + 8;
    }
};
const Float16_BE = {
    len: 2,
    get (dataView, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["read"](dataView, offset, false, 10, this.len);
    },
    put (dataView, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["write"](dataView, value, offset, false, 10, this.len);
        return offset + this.len;
    }
};
const Float16_LE = {
    len: 2,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["read"](array, offset, true, 10, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["write"](array, value, offset, true, 10, this.len);
        return offset + this.len;
    }
};
const Float32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getFloat32(offset);
    },
    put (array, offset, value) {
        dv(array).setFloat32(offset, value);
        return offset + 4;
    }
};
const Float32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getFloat32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setFloat32(offset, value, true);
        return offset + 4;
    }
};
const Float64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getFloat64(offset);
    },
    put (array, offset, value) {
        dv(array).setFloat64(offset, value);
        return offset + 8;
    }
};
const Float64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getFloat64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setFloat64(offset, value, true);
        return offset + 8;
    }
};
const Float80_BE = {
    len: 10,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["read"](array, offset, false, 63, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["write"](array, value, offset, false, 63, this.len);
        return offset + this.len;
    }
};
const Float80_LE = {
    len: 10,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["read"](array, offset, true, 63, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["write"](array, value, offset, true, 63, this.len);
        return offset + this.len;
    }
};
class IgnoreType {
    /**
     * @param len number of bytes to ignore
     */ constructor(len){
        this.len = len;
    }
    // ToDo: don't read, but skip data
    get(_array, _off) {}
}
class Uint8ArrayType {
    constructor(len){
        this.len = len;
    }
    get(array, offset) {
        return array.subarray(offset, offset + this.len);
    }
}
class StringType {
    constructor(len, encoding){
        this.len = len;
        this.encoding = encoding;
    }
    get(data, offset = 0) {
        const bytes = data.subarray(offset, offset + this.len);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$borewit$2b$text$2d$codec$40$0$2e$1$2e$1$2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["textDecode"])(bytes, this.encoding);
    }
}
class AnsiStringType extends StringType {
    constructor(len){
        super(len, 'windows-1252');
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "EndOfStreamError",
    ()=>EndOfStreamError,
    "defaultMessages",
    ()=>defaultMessages
]);
const defaultMessages = 'End-Of-Stream';
class EndOfStreamError extends Error {
    constructor(){
        super(defaultMessages);
        this.name = "EndOfStreamError";
    }
}
class AbortError extends Error {
    constructor(message = "The operation was aborted"){
        super(message);
        this.name = "AbortError";
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Deferred.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Deferred",
    ()=>Deferred
]);
class Deferred {
    constructor(){
        this.resolve = ()=>null;
        this.reject = ()=>null;
        this.promise = new Promise((resolve, reject)=>{
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/AbstractStreamReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractStreamReader",
    ()=>AbstractStreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
;
class AbstractStreamReader {
    constructor(){
        this.endOfStream = false;
        this.interrupted = false;
        /**
         * Store peeked data
         * @type {Array}
         */ this.peekQueue = [];
    }
    async peek(uint8Array, mayBeLess = false) {
        const bytesRead = await this.read(uint8Array, mayBeLess);
        this.peekQueue.push(uint8Array.subarray(0, bytesRead)); // Put read data back to peek buffer
        return bytesRead;
    }
    async read(buffer, mayBeLess = false) {
        if (buffer.length === 0) {
            return 0;
        }
        let bytesRead = this.readFromPeekBuffer(buffer);
        if (!this.endOfStream) {
            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
        }
        if (bytesRead === 0 && !mayBeLess) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @returns Number of bytes read
     */ readFromPeekBuffer(buffer) {
        let remaining = buffer.length;
        let bytesRead = 0;
        // consume peeked data first
        while(this.peekQueue.length > 0 && remaining > 0){
            const peekData = this.peekQueue.pop(); // Front of queue
            if (!peekData) throw new Error('peekData should be defined');
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
                // remainder back to queue
                this.peekQueue.push(peekData.subarray(lenCopy));
            }
        }
        return bytesRead;
    }
    async readRemainderFromStream(buffer, mayBeLess) {
        let bytesRead = 0;
        // Continue reading from stream if required
        while(bytesRead < buffer.length && !this.endOfStream){
            if (this.interrupted) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]();
            }
            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
            if (chunkLen === 0) break;
            bytesRead += chunkLen;
        }
        if (!mayBeLess && bytesRead < buffer.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return bytesRead;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/StreamReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StreamReader",
    ()=>StreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Deferred$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Deferred.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/AbstractStreamReader.js [app-route] (ecmascript)");
;
;
;
class StreamReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractStreamReader"] {
    constructor(s){
        super();
        this.s = s;
        /**
         * Deferred used for postponed read request (as not data is yet available to read)
         */ this.deferred = null;
        if (!s.read || !s.once) {
            throw new Error('Expected an instance of stream.Readable');
        }
        this.s.once('end', ()=>{
            this.endOfStream = true;
            if (this.deferred) {
                this.deferred.resolve(0);
            }
        });
        this.s.once('error', (err)=>this.reject(err));
        this.s.once('close', ()=>this.abort());
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @returns Number of bytes read
     */ async readFromStream(buffer, mayBeLess) {
        if (buffer.length === 0) return 0;
        const readBuffer = this.s.read(buffer.length);
        if (readBuffer) {
            buffer.set(readBuffer);
            return readBuffer.length;
        }
        const request = {
            buffer,
            mayBeLess,
            deferred: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Deferred$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Deferred"]()
        };
        this.deferred = request.deferred;
        this.s.once('readable', ()=>{
            this.readDeferred(request);
        });
        return request.deferred.promise;
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */ readDeferred(request) {
        const readBuffer = this.s.read(request.buffer.length);
        if (readBuffer) {
            request.buffer.set(readBuffer);
            request.deferred.resolve(readBuffer.length);
            this.deferred = null;
        } else {
            this.s.once('readable', ()=>{
                this.readDeferred(request);
            });
        }
    }
    reject(err) {
        this.interrupted = true;
        if (this.deferred) {
            this.deferred.reject(err);
            this.deferred = null;
        }
    }
    async abort() {
        this.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbortError"]());
    }
    async close() {
        return this.abort();
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebStreamReader",
    ()=>WebStreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/AbstractStreamReader.js [app-route] (ecmascript)");
;
class WebStreamReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractStreamReader"] {
    constructor(reader){
        super();
        this.reader = reader;
    }
    async abort() {
        return this.close();
    }
    async close() {
        this.reader.releaseLock();
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamByobReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebStreamByobReader",
    ()=>WebStreamByobReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamReader.js [app-route] (ecmascript)");
;
class WebStreamByobReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebStreamReader"] {
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */ async readFromStream(buffer, mayBeLess) {
        if (buffer.length === 0) return 0;
        // @ts-ignore
        const result = await this.reader.read(new Uint8Array(buffer.length), {
            min: mayBeLess ? undefined : buffer.length
        });
        if (result.done) {
            this.endOfStream = result.done;
        }
        if (result.value) {
            buffer.set(result.value);
            return result.value.length;
        }
        return 0;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamDefaultReader.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebStreamDefaultReader",
    ()=>WebStreamDefaultReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/AbstractStreamReader.js [app-route] (ecmascript)");
;
;
class WebStreamDefaultReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$AbstractStreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractStreamReader"] {
    constructor(reader){
        super();
        this.reader = reader;
        this.buffer = null; // Internal buffer to store excess data
    }
    /**
     * Copy chunk to target, and store the remainder in this.buffer
     */ writeChunk(target, chunk) {
        const written = Math.min(chunk.length, target.length);
        target.set(chunk.subarray(0, written));
        // Adjust the remainder of the buffer
        if (written < chunk.length) {
            this.buffer = chunk.subarray(written);
        } else {
            this.buffer = null;
        }
        return written;
    }
    /**
     * Read from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param mayBeLess - If true, may fill the buffer partially
     * @protected Bytes read
     */ async readFromStream(buffer, mayBeLess) {
        if (buffer.length === 0) return 0;
        let totalBytesRead = 0;
        // Serve from the internal buffer first
        if (this.buffer) {
            totalBytesRead += this.writeChunk(buffer, this.buffer);
        }
        // Continue reading from the stream if more data is needed
        while(totalBytesRead < buffer.length && !this.endOfStream){
            const result = await this.reader.read();
            if (result.done) {
                this.endOfStream = true;
                break;
            }
            if (result.value) {
                totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
            }
        }
        if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return totalBytesRead;
    }
    abort() {
        this.interrupted = true;
        return this.reader.cancel();
    }
    async close() {
        await this.abort();
        this.reader.releaseLock();
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamReaderFactory.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeWebStreamReader",
    ()=>makeWebStreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamByobReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamByobReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamDefaultReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamDefaultReader.js [app-route] (ecmascript)");
;
;
function makeWebStreamReader(stream) {
    try {
        const reader = stream.getReader({
            mode: "byob"
        });
        if (reader instanceof ReadableStreamDefaultReader) {
            // Fallback to default reader in case `mode: byob` is ignored
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamDefaultReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebStreamDefaultReader"](reader);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamByobReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebStreamByobReader"](reader);
    } catch (error) {
        if (error instanceof TypeError) {
            // Fallback to default reader in case `mode: byob` rejected by a `TypeError`
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamDefaultReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebStreamDefaultReader"](stream.getReader());
        }
        throw error;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$StreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/StreamReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamByobReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamByobReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamDefaultReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamDefaultReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamReaderFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamReaderFactory.js [app-route] (ecmascript)");
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/AbstractTokenizer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractTokenizer",
    ()=>AbstractTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
;
class AbstractTokenizer {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */ constructor(options){
        this.numBuffer = new Uint8Array(8);
        /**
         * Tokenizer-stream position
         */ this.position = 0;
        this.onClose = options?.onClose;
        if (options?.abortSignal) {
            options.abortSignal.addEventListener('abort', ()=>{
                this.abort();
            });
        }
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */ async readToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.readBuffer(uint8Array, {
            position
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */ async peekToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.peekBuffer(uint8Array, {
            position
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */ async ignore(length) {
        if (this.fileInfo.size !== undefined) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
                this.position += bytesLeft;
                return bytesLeft;
            }
        }
        this.position += length;
        return length;
    }
    async close() {
        await this.abort();
        await this.onClose?.();
    }
    normalizeOptions(uint8Array, options) {
        if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        return {
            ...{
                mayBeLess: false,
                offset: 0,
                length: uint8Array.length,
                position: this.position
            },
            ...options
        };
    }
    abort() {
        return Promise.resolve(); // Ignore abort signal
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/ReadStreamTokenizer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReadStreamTokenizer",
    ()=>ReadStreamTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/AbstractTokenizer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
;
;
const maxBufferSize = 256000;
class ReadStreamTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */ constructor(streamReader, options){
        super(options);
        this.streamReader = streamReader;
        this.fileInfo = options?.fileInfo ?? {};
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */ async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
        }
        if (skipBytes < 0) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (normOptions.length === 0) {
            return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                bytesRead = await this.peekBuffer(skipBuffer, {
                    mayBeLess: normOptions.mayBeLess
                });
                uint8Array.set(skipBuffer.subarray(skipBytes));
                return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
                throw new Error('Cannot peek from a negative offset in a stream');
            }
        }
        if (normOptions.length > 0) {
            try {
                bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
            } catch (err) {
                if (options?.mayBeLess && err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]) {
                    return 0;
                }
                throw err;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
            }
        }
        return bytesRead;
    }
    async ignore(length) {
        // debug(`ignore ${this.position}...${this.position + length - 1}`);
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while(totBytesRead < length){
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, {
                length: Math.min(bufSize, remaining)
            });
            if (bytesRead < 0) {
                return bytesRead;
            }
            totBytesRead += bytesRead;
        }
        return totBytesRead;
    }
    abort() {
        return this.streamReader.abort();
    }
    async close() {
        return this.streamReader.close();
    }
    supportsRandomAccess() {
        return false;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/BufferTokenizer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BufferTokenizer",
    ()=>BufferTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/AbstractTokenizer.js [app-route] (ecmascript)");
;
;
class BufferTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */ constructor(uint8Array, options){
        super(options);
        this.uint8Array = uint8Array;
        this.fileInfo = {
            ...options?.fileInfo ?? {},
            ...{
                size: uint8Array.length
            }
        };
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async readBuffer(uint8Array, options) {
        if (options?.position) {
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
        return bytes2read;
    }
    close() {
        return super.close();
    }
    supportsRandomAccess() {
        return true;
    }
    setPosition(position) {
        this.position = position;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/BlobTokenizer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BlobTokenizer",
    ()=>BlobTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/AbstractTokenizer.js [app-route] (ecmascript)");
;
;
class BlobTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    /**
     * Construct BufferTokenizer
     * @param blob - Uint8Array to tokenize
     * @param options Tokenizer options
     */ constructor(blob, options){
        super(options);
        this.blob = blob;
        this.fileInfo = {
            ...options?.fileInfo ?? {},
            ...{
                size: blob.size,
                mimeType: blob.type
            }
        };
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async readBuffer(uint8Array, options) {
        if (options?.position) {
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param buffer
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async peekBuffer(buffer, options) {
        const normOptions = this.normalizeOptions(buffer, options);
        const bytes2read = Math.min(this.blob.size - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        const arrayBuffer = await this.blob.slice(normOptions.position, normOptions.position + bytes2read).arrayBuffer();
        buffer.set(new Uint8Array(arrayBuffer));
        return bytes2read;
    }
    close() {
        return super.close();
    }
    supportsRandomAccess() {
        return true;
    }
    setPosition(position) {
        this.position = position;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/core.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromBlob",
    ()=>fromBlob,
    "fromBuffer",
    ()=>fromBuffer,
    "fromStream",
    ()=>fromStream,
    "fromWebStream",
    ()=>fromWebStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$StreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/StreamReader.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamReaderFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/WebStreamReaderFactory.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/ReadStreamTokenizer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$BufferTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/BufferTokenizer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$BlobTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/BlobTokenizer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/AbstractTokenizer.js [app-route] (ecmascript)");
;
;
;
;
;
;
function fromStream(stream, options) {
    const streamReader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$StreamReader$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StreamReader"](stream);
    const _options = options ?? {};
    const chainedClose = _options.onClose;
    _options.onClose = async ()=>{
        await streamReader.close();
        if (chainedClose) {
            return chainedClose();
        }
    };
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ReadStreamTokenizer"](streamReader, _options);
}
function fromWebStream(webStream, options) {
    const webStreamReader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$WebStreamReaderFactory$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeWebStreamReader"])(webStream);
    const _options = options ?? {};
    const chainedClose = _options.onClose;
    _options.onClose = async ()=>{
        await webStreamReader.close();
        if (chainedClose) {
            return chainedClose();
        }
    };
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ReadStreamTokenizer"](webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$BufferTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BufferTokenizer"](uint8Array, options);
}
function fromBlob(blob, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$BlobTokenizer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BlobTokenizer"](blob, options);
}
}),
"[project]/node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AsyncCompress",
    ()=>AsyncGzip,
    "AsyncDecompress",
    ()=>AsyncDecompress,
    "AsyncDeflate",
    ()=>AsyncDeflate,
    "AsyncGunzip",
    ()=>AsyncGunzip,
    "AsyncGzip",
    ()=>AsyncGzip,
    "AsyncInflate",
    ()=>AsyncInflate,
    "AsyncUnzipInflate",
    ()=>AsyncUnzipInflate,
    "AsyncUnzlib",
    ()=>AsyncUnzlib,
    "AsyncZipDeflate",
    ()=>AsyncZipDeflate,
    "AsyncZlib",
    ()=>AsyncZlib,
    "Compress",
    ()=>Gzip,
    "DecodeUTF8",
    ()=>DecodeUTF8,
    "Decompress",
    ()=>Decompress,
    "Deflate",
    ()=>Deflate,
    "EncodeUTF8",
    ()=>EncodeUTF8,
    "FlateErrorCode",
    ()=>FlateErrorCode,
    "Gunzip",
    ()=>Gunzip,
    "Gzip",
    ()=>Gzip,
    "Inflate",
    ()=>Inflate,
    "Unzip",
    ()=>Unzip,
    "UnzipInflate",
    ()=>UnzipInflate,
    "UnzipPassThrough",
    ()=>UnzipPassThrough,
    "Unzlib",
    ()=>Unzlib,
    "Zip",
    ()=>Zip,
    "ZipDeflate",
    ()=>ZipDeflate,
    "ZipPassThrough",
    ()=>ZipPassThrough,
    "Zlib",
    ()=>Zlib,
    "compress",
    ()=>gzip,
    "compressSync",
    ()=>gzipSync,
    "decompress",
    ()=>decompress,
    "decompressSync",
    ()=>decompressSync,
    "deflate",
    ()=>deflate,
    "deflateSync",
    ()=>deflateSync,
    "gunzip",
    ()=>gunzip,
    "gunzipSync",
    ()=>gunzipSync,
    "gzip",
    ()=>gzip,
    "gzipSync",
    ()=>gzipSync,
    "inflate",
    ()=>inflate,
    "inflateSync",
    ()=>inflateSync,
    "strFromU8",
    ()=>strFromU8,
    "strToU8",
    ()=>strToU8,
    "unzip",
    ()=>unzip,
    "unzipSync",
    ()=>unzipSync,
    "unzlib",
    ()=>unzlib,
    "unzlibSync",
    ()=>unzlibSync,
    "zip",
    ()=>zip,
    "zipSync",
    ()=>zipSync,
    "zlib",
    ()=>zlib,
    "zlibSync",
    ()=>zlibSync
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
;
var require = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["createRequire"])('/');
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
// Mediocre shim
var Worker;
var workerAdd = ";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global";
try {
    Worker = require('worker_threads').Worker;
} catch (e) {}
var wk = Worker ? function(c, _, msg, transfer, cb) {
    var done = false;
    var w = new Worker(c + workerAdd, {
        eval: true
    }).on('error', function(e) {
        return cb(e, null);
    }).on('message', function(m) {
        return cb(null, m);
    }).on('exit', function(c) {
        if (c && !done) cb(new Error('exited with code ' + c), null);
    });
    w.postMessage(msg, transfer);
    w.terminate = function() {
        done = true;
        return Worker.prototype.terminate.call(w);
    };
    return w;
} : function(_, __, ___, ____, cb) {
    setImmediate(function() {
        return cb(new Error('async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)'), null);
    });
    var NOP = function() {};
    return {
        terminate: NOP,
        postMessage: NOP
    };
};
// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */ 0,
    0,
    /* impossible */ 0
]);
// fixed distance extra bits
var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */ 0,
    0
]);
// code length index map
var clim = new u8([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
// get base, reverse index map from extra bits
var freb = function(eb, start) {
    var b = new u16(31);
    for(var i = 0; i < 31; ++i){
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for(var i = 1; i < 30; ++i){
        for(var j = b[i]; j < b[i + 1]; ++j){
            r[j] = j - b[i] << 5 | i;
        }
    }
    return {
        b: b,
        r: r
    };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for(var i = 0; i < 32768; ++i){
    // reverse table algorithm from SO
    var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = function(cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for(; i < s; ++i){
        if (cd[i]) ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for(i = 1; i < mb; ++i){
        le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for(i = 0; i < s; ++i){
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = i << 4 | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for(var m = v | (1 << r_1) - 1; v <= m; ++v){
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >> rvb] = sv;
                }
            }
        }
    } else {
        co = new u16(s);
        for(i = 0; i < s; ++i){
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
            }
        }
    }
    return co;
};
// fixed length tree
var flt = new u8(288);
for(var i = 0; i < 144; ++i)flt[i] = 8;
for(var i = 144; i < 256; ++i)flt[i] = 9;
for(var i = 256; i < 280; ++i)flt[i] = 7;
for(var i = 280; i < 288; ++i)flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for(var i = 0; i < 32; ++i)fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function(a) {
    var m = a[0];
    for(var i = 1; i < a.length; ++i){
        if (a[i] > m) m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
// get end of byte
var shft = function(p) {
    return (p + 7) / 8 | 0;
};
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function(v, s, e) {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length;
    // can't use .constructor in case user-supplied
    return new u8(v.subarray(s, e));
};
var FlateErrorCode = {
    UnexpectedEOF: 0,
    InvalidBlockType: 1,
    InvalidLengthLiteral: 2,
    InvalidDistance: 3,
    StreamFinished: 4,
    NoStreamHandler: 5,
    InvalidHeader: 6,
    NoCallback: 7,
    InvalidUTF8: 8,
    ExtraFieldTooLong: 9,
    InvalidDate: 10,
    FilenameTooLong: 11,
    StreamFinishing: 12,
    InvalidZipData: 13,
    UnknownCompressionMethod: 14
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
];
;
var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace) Error.captureStackTrace(e, err);
    if (!nt) throw e;
    return e;
};
// expands raw DEFLATE data
var inflt = function(dat, st, buf, dict) {
    // source length       dict length
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l) return buf || new u8(0);
    var noBuf = !buf;
    // have to estimate size
    var resize = noBuf || st.i != 2;
    // no state
    var noSt = st.i;
    // Assumes roughly 33% compression ratio average
    if (noBuf) buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function(l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                if (t > sl) {
                    if (noSt) err(0);
                    break;
                }
                // ensure size
                if (resize) cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8, st.f = final;
                continue;
            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for(var i = 0; i < hcLen; ++i){
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for(var i = 0; i < tl;){
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    } else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
                        while(n--)ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            } else err(1);
            if (pos > tbts) {
                if (noSt) err(0);
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17
        if (resize) cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for(;; lpos = pos){
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt) err(0);
                break;
            }
            if (!c) err(2);
            if (sym < 256) buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            } else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                if (!d) err(3);
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts) {
                    if (noSt) err(0);
                    break;
                }
                if (resize) cbuf(bt + 131072);
                var end = bt + add;
                if (bt < dt) {
                    var shift = dl - dt, dend = Math.min(dt, end);
                    if (shift + bt < 0) err(3);
                    for(; bt < dend; ++bt)buf[bt] = dict[shift + bt];
                }
                for(; bt < end; ++bt)buf[bt] = buf[bt - dt];
            }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    }while (!final)
    // don't reallocate for streams or user buffers
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
};
// creates code lengths from a frequency table
var hTree = function(d, mb) {
    // Need extra info to make a tree
    var t = [];
    for(var i = 0; i < d.length; ++i){
        if (d[i]) t.push({
            s: i,
            f: d[i]
        });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s) return {
        t: et,
        l: 0
    };
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return {
            t: v,
            l: 1
        };
    }
    t.sort(function(a, b) {
        return a.f - b.f;
    });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({
        s: -1,
        f: 25001
    });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = {
        s: -1,
        f: l.f + r.f,
        l: l,
        r: r
    };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while(i1 != s - 1){
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = {
            s: -1,
            f: l.f + r.f,
            l: l,
            r: r
        };
    }
    var maxSym = t2[0].s;
    for(var i = 1; i < s; ++i){
        if (t2[i].s > maxSym) maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
            return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for(; i < s; ++i){
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << mbt - tr[i2_1]);
                tr[i2_1] = mb;
            } else break;
        }
        dt >>= lft;
        while(dt > 0){
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;
            else ++i;
        }
        for(; i >= 0 && dt; --i){
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return {
        t: new u8(tr),
        l: mbt
    };
};
// get the max length and assign length codes
var ln = function(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
// length codes generation
var lc = function(c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while(s && !c[--s]);
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function(v) {
        cl[cli++] = v;
    };
    for(var i = 1; i <= s; ++i){
        if (c[i] == cln && i != s) ++cls;
        else {
            if (!cln && cls > 2) {
                for(; cls > 138; cls -= 138)w(32754);
                if (cls > 2) {
                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                    cls = 0;
                }
            } else if (cls > 3) {
                w(cln), --cls;
                for(; cls > 6; cls -= 6)w(8304);
                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
            }
            while(cls--)w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return {
        c: cl.subarray(0, cli),
        n: s
    };
};
// calculate the length of output from tree, code lengths
var clen = function(cf, cl) {
    var l = 0;
    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function(out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for(var i = 0; i < lclt.length; ++i)++lcfreq[lclt[i] & 31];
    for(var i = 0; i < lcdt.length; ++i)++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [
            lclt,
            lcdt
        ];
        for(var it = 0; it < 2; ++it){
            var clct = lcts[it];
            for(var i = 0; i < clct.length; ++i){
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
            }
        }
    } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for(var i = 0; i < li; ++i){
        var sym = syms[i];
        if (sym > 255) {
            var len = sym >> 18 & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
            var dst = sym & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
        } else {
            wbits16(out, p, lm[sym]), p += ll[sym];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new i32([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function(dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
        if (pos) w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i) {
            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
        };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new i32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for(; i + 2 < s; ++i){
            // hash value
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for(var j = 0; j < 286; ++j)lf[j] = 0;
                    for(var j = 0; j < 30; ++j)df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while(dif <= maxd && --ch_1 && imod != pimod){
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn) break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for(var j = 0; j < mmd; ++j){
                                    var ti = i - dif + j & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti & 32767;
                                    if (cd > md) md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one int32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                } else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        for(i = Math.max(i, wi); i < s; ++i){
            syms[li++] = dat[i];
            ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
            st.r = pos & 7 | w[pos / 8 | 0] << 3;
            // shft(pos) now 1 less if pos & 7 != 0
            pos -= 7;
            st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
    } else {
        for(var i = st.w || 0; i < s + lst; i += 65535){
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[pos / 8 | 0] = lst;
                e = s;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ function() {
    var t = new Int32Array(256);
    for(var i = 0; i < 256; ++i){
        var c = i, k = 9;
        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;
        t[i] = c;
    }
    return t;
}();
// CRC32
var crc = function() {
    var c = -1;
    return {
        p: function(d) {
            // closures have awful performance
            var cr = c;
            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
            c = cr;
        },
        d: function() {
            return ~c;
        }
    };
};
// Adler32
var adler = function() {
    var a = 1, b = 0;
    return {
        p: function(d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length | 0;
            for(var i = 0; i != l;){
                var e = Math.min(i + 2655, l);
                for(; i < e; ++i)m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function() {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | b >> 8;
        }
    };
};
;
// deflate with opts
var dopt = function(dat, opt, pre, post, st) {
    if (!st) {
        st = {
            l: 1
        };
        if (opt.dictionary) {
            var dict = opt.dictionary.subarray(-32768);
            var newDat = new u8(dict.length + dat.length);
            newDat.set(dict);
            newDat.set(dat, dict.length);
            dat = newDat;
            st.w = dict.length;
        }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
// Walmart object spread
var mrg = function(a, b) {
    var o = {};
    for(var k in a)o[k] = a[k];
    for(var k in b)o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function(fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\s+/g, '').split(',');
    for(var i = 0; i < dt.length; ++i){
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                } else {
                    fnStr += st_1;
                    for(var t in v.prototype)fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            } else fnStr += st_1;
        } else td[k] = v;
    }
    return fnStr;
};
var ch = [];
// clone bufs
var cbfs = function(v) {
    var tl = [];
    for(var k in v){
        if (v[k].buffer) {
            tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
    }
    return tl;
};
// use a worker to execute code
var wrkr = function(fns, init, id, cb) {
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for(var i = 0; i < m; ++i)fnStr = wcln(fns[i], fnStr, td_1);
        ch[id] = {
            c: wcln(fns[m], fnStr, td_1),
            e: td_1
        };
    }
    var td = mrg({}, ch[id].e);
    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
// base async inflate fn
var bInflt = function() {
    return [
        u8,
        u16,
        i32,
        fleb,
        fdeb,
        clim,
        fl,
        fd,
        flrm,
        fdrm,
        rev,
        ec,
        hMap,
        max,
        bits,
        bits16,
        shft,
        slc,
        err,
        inflt,
        inflateSync,
        pbf,
        gopt
    ];
};
var bDflt = function() {
    return [
        u8,
        u16,
        i32,
        fleb,
        fdeb,
        clim,
        revfl,
        revfd,
        flm,
        flt,
        fdm,
        fdt,
        rev,
        deo,
        et,
        hMap,
        wbits,
        wbits16,
        hTree,
        ln,
        lc,
        clen,
        wfblk,
        wblk,
        shft,
        slc,
        dflt,
        dopt,
        deflateSync,
        pbf
    ];
};
// gzip extra
var gze = function() {
    return [
        gzh,
        gzhl,
        wbytes,
        crc,
        crct
    ];
};
// gunzip extra
var guze = function() {
    return [
        gzs,
        gzl
    ];
};
// zlib extra
var zle = function() {
    return [
        zlh,
        wbytes,
        adler
    ];
};
// unzlib extra
var zule = function() {
    return [
        zls
    ];
};
// post buf
var pbf = function(msg) {
    return postMessage(msg, [
        msg.buffer
    ]);
};
// get opts
var gopt = function(o) {
    return o && {
        out: o.size && new u8(o.size),
        dictionary: o.dictionary
    };
};
// async helper
var cbify = function(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function(err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([
        dat,
        opts
    ], opts.consume ? [
        dat.buffer
    ] : []);
    return function() {
        w.terminate();
    };
};
// auto stream
var astrm = function(strm) {
    strm.ondata = function(dat, final) {
        return postMessage([
            dat,
            final
        ], [
            dat.buffer
        ]);
    };
    return function(ev) {
        if (ev.data.length) {
            strm.push(ev.data[0], ev.data[1]);
            postMessage([
                ev.data[0].length
            ]);
        } else strm.flush();
    };
};
// async stream attach
var astrmify = function(fns, strm, opts, init, id, flush, ext) {
    var t;
    var w = wrkr(fns, init, id, function(err, dat) {
        if (err) w.terminate(), strm.ondata.call(strm, err);
        else if (!Array.isArray(dat)) ext(dat);
        else if (dat.length == 1) {
            strm.queuedSize -= dat[0];
            if (strm.ondrain) strm.ondrain(dat[0]);
        } else {
            if (dat[1]) w.terminate();
            strm.ondata.call(strm, err, dat[0], dat[1]);
        }
    });
    w.postMessage(opts);
    strm.queuedSize = 0;
    strm.push = function(d, f) {
        if (!strm.ondata) err(5);
        if (t) strm.ondata(err(4, 0, 1), null, !!f);
        strm.queuedSize += d.length;
        w.postMessage([
            d,
            t = f
        ], [
            d.buffer
        ]);
    };
    strm.terminate = function() {
        w.terminate();
    };
    if (flush) {
        strm.flush = function() {
            w.postMessage([]);
        };
    }
};
// read 2 bytes
var b2 = function(d, b) {
    return d[b] | d[b + 1] << 8;
};
// read 4 bytes
var b4 = function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
};
// write bytes
var wbytes = function(d, b, v) {
    for(; v; ++b)d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start
var gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, 'invalid gzip data');
    var flg = d[3];
    var st = 10;
    if (flg & 4) st += (d[10] | d[11] << 8) + 2;
    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);
    return st + (flg & 2);
};
// gzip length
var gzl = function(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
// gzip header length
var gzhl = function(o) {
    return 10 + (o.filename ? o.filename.length + 1 : 0);
};
// zlib header
var zlh = function(c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = fl << 6 | (o.dictionary && 32);
    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
    if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
    }
};
// zlib start
var zls = function(d, dict) {
    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) err(6, 'invalid zlib data');
    if ((d[1] >> 5 & 1) == +!dict) err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');
    return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
    if (typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    return opts;
}
/**
 * Streaming DEFLATE compression
 */ var Deflate = function() {
    function Deflate(opts, cb) {
        if (typeof opts == 'function') cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = {
            l: 0,
            i: 32768,
            w: 32768,
            z: 32768
        };
        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev
        // 98304 = 32768 (lookback) + 65536 (common chunk size)
        this.b = new u8(98304);
        if (this.o.dictionary) {
            var dict = this.o.dictionary.subarray(-32768);
            this.b.set(dict, 32768 - dict.length);
            this.s.i = 32768 - dict.length;
        }
    }
    Deflate.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Deflate.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (this.s.l) err(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
            if (endLen > 2 * this.b.length - 32768) {
                var newBuf = new u8(endLen & -32768);
                newBuf.set(this.b.subarray(0, this.s.z));
                this.b = newBuf;
            }
            var split = this.b.length - this.s.z;
            this.b.set(chunk.subarray(0, split), this.s.z);
            this.s.z = this.b.length;
            this.p(this.b, false);
            this.b.set(this.b.subarray(-32768));
            this.b.set(chunk.subarray(split), 32768);
            this.s.z = chunk.length - split + 32768;
            this.s.i = 32766, this.s.w = 32768;
        } else {
            this.b.set(chunk, this.s.z);
            this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
            this.p(this.b, final || false);
            this.s.w = this.s.i, this.s.i -= 2;
        }
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * deflated output for small inputs.
     */ Deflate.prototype.flush = function() {
        if (!this.ondata) err(5);
        if (this.s.l) err(4);
        this.p(this.b, false);
        this.s.w = this.s.i, this.s.i -= 2;
    };
    return Deflate;
}();
;
/**
 * Asynchronous streaming DEFLATE compression
 */ var AsyncDeflate = function() {
    function AsyncDeflate(opts, cb) {
        astrmify([
            bDflt,
            function() {
                return [
                    astrm,
                    Deflate
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Deflate(ev.data);
            onmessage = astrm(strm);
        }, 6, 1);
    }
    return AsyncDeflate;
}();
;
function deflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt
    ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
    }, 0, cb);
}
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */ var Inflate = function() {
    function Inflate(opts, cb) {
        // no StrmOpt here to avoid adding to workerizer
        if (typeof opts == 'function') cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = {
            i: 0,
            b: dict ? dict.length : 0
        };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict) this.o.set(dict);
    }
    Inflate.prototype.e = function(c) {
        if (!this.ondata) err(5);
        if (this.d) err(4);
        if (!this.p.length) this.p = c;
        else if (c.length) {
            var n = new u8(this.p.length + c.length);
            n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
    };
    Inflate.prototype.c = function(final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */ Inflate.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
    };
    return Inflate;
}();
;
/**
 * Asynchronous streaming DEFLATE decompression
 */ var AsyncInflate = function() {
    function AsyncInflate(opts, cb) {
        astrmify([
            bInflt,
            function() {
                return [
                    astrm,
                    Inflate
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Inflate(ev.data);
            onmessage = astrm(strm);
        }, 7, 0);
    }
    return AsyncInflate;
}();
;
function inflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt
    ], function(ev) {
        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
    }, 1, cb);
}
function inflateSync(data, opts) {
    return inflt(data, {
        i: 2
    }, opts && opts.out, opts && opts.dictionary);
}
// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */ var Gzip = function() {
    function Gzip(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gzip.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate.prototype.push.call(this, chunk, final);
    };
    Gzip.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
        if (this.v) gzh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * GZIPped output for small inputs.
     */ Gzip.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
    };
    return Gzip;
}();
;
/**
 * Asynchronous streaming GZIP compression
 */ var AsyncGzip = function() {
    function AsyncGzip(opts, cb) {
        astrmify([
            bDflt,
            gze,
            function() {
                return [
                    astrm,
                    Deflate,
                    Gzip
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Gzip(ev.data);
            onmessage = astrm(strm);
        }, 8, 1);
    }
    return AsyncGzip;
}();
;
function gzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt,
        gze,
        function() {
            return [
                gzipSync
            ];
        }
    ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
    }, 2, cb);
}
function gzipSync(data, opts) {
    if (!opts) opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming single or multi-member GZIP decompression
 */ var Gunzip = function() {
    function Gunzip(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gunzip.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
            var p = this.p.subarray(this.v - 1);
            var s = p.length > 3 ? gzs(p) : 4;
            if (s > p.length) {
                if (!final) return;
            } else if (this.v > 1 && this.onmember) {
                this.onmember(this.r - p.length);
            }
            this.p = p.subarray(s), this.v = 0;
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
        // process concatenated GZIP
        if (this.s.f && !this.s.l && !final) {
            this.v = shft(this.s.p) + 9;
            this.s = {
                i: 0
            };
            this.o = new u8(0);
            this.push(new u8(0), final);
        }
    };
    return Gunzip;
}();
;
/**
 * Asynchronous streaming single or multi-member GZIP decompression
 */ var AsyncGunzip = function() {
    function AsyncGunzip(opts, cb) {
        var _this = this;
        astrmify([
            bInflt,
            guze,
            function() {
                return [
                    astrm,
                    Inflate,
                    Gunzip
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Gunzip(ev.data);
            strm.onmember = function(offset) {
                return postMessage(offset);
            };
            onmessage = astrm(strm);
        }, 9, 0, function(offset) {
            return _this.onmember && _this.onmember(offset);
        });
    }
    return AsyncGunzip;
}();
;
function gunzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt,
        guze,
        function() {
            return [
                gunzipSync
            ];
        }
    ], function(ev) {
        return pbf(gunzipSync(ev.data[0], ev.data[1]));
    }, 3, cb);
}
function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length) err(6, 'invalid gzip data');
    return inflt(data.subarray(st, -8), {
        i: 2
    }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
/**
 * Streaming Zlib compression
 */ var Zlib = function() {
    function Zlib(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Zlib.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        Deflate.prototype.push.call(this, chunk, final);
    };
    Zlib.prototype.p = function(c, f) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
        if (this.v) zlh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
    };
    /**
     * Flushes buffered uncompressed data. Useful to immediately retrieve the
     * zlibbed output for small inputs.
     */ Zlib.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
    };
    return Zlib;
}();
;
/**
 * Asynchronous streaming Zlib compression
 */ var AsyncZlib = function() {
    function AsyncZlib(opts, cb) {
        astrmify([
            bDflt,
            zle,
            function() {
                return [
                    astrm,
                    Deflate,
                    Zlib
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Zlib(ev.data);
            onmessage = astrm(strm);
        }, 10, 1);
    }
    return AsyncZlib;
}();
;
function zlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bDflt,
        zle,
        function() {
            return [
                zlibSync
            ];
        }
    ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
    }, 4, cb);
}
function zlibSync(data, opts) {
    if (!opts) opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */ var Unzlib = function() {
    function Unzlib(opts, cb) {
        Inflate.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzlib.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            if (this.p.length < 6 && !final) return;
            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
            if (this.p.length < 4) err(6, 'invalid zlib data');
            this.p = this.p.subarray(0, -4);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
    };
    return Unzlib;
}();
;
/**
 * Asynchronous streaming Zlib decompression
 */ var AsyncUnzlib = function() {
    function AsyncUnzlib(opts, cb) {
        astrmify([
            bInflt,
            zule,
            function() {
                return [
                    astrm,
                    Inflate,
                    Unzlib
                ];
            }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
            var strm = new Unzlib(ev.data);
            onmessage = astrm(strm);
        }, 11, 0);
    }
    return AsyncUnzlib;
}();
;
function unzlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return cbify(data, opts, [
        bInflt,
        zule,
        function() {
            return [
                unzlibSync
            ];
        }
    ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
    }, 5, cb);
}
function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
        i: 2
    }, opts && opts.out, opts && opts.dictionary);
}
;
;
/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var Decompress = function() {
    function Decompress(opts, cb) {
        this.o = StrmOpt.call(this, opts, cb) || {};
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
    }
    // init substream
    // overriden by AsyncDecompress
    Decompress.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(dat, final) {
            _this.ondata(dat, final);
        };
    };
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Decompress.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (!this.s) {
            if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
            } else this.p = chunk;
            if (this.p.length > 2) {
                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
                this.i();
                this.s.push(this.p, final);
                this.p = null;
            }
        } else this.s.push(chunk, final);
    };
    return Decompress;
}();
;
/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var AsyncDecompress = function() {
    function AsyncDecompress(opts, cb) {
        Decompress.call(this, opts, cb);
        this.queuedSize = 0;
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
    }
    AsyncDecompress.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(err, dat, final) {
            _this.ondata(err, dat, final);
        };
        this.s.ondrain = function(size) {
            _this.queuedSize -= size;
            if (_this.ondrain) _this.ondrain(size);
        };
    };
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncDecompress.prototype.push = function(chunk, final) {
        this.queuedSize += chunk.length;
        Decompress.prototype.push.call(this, chunk, final);
    };
    return AsyncDecompress;
}();
;
function decompress(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
}
function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
// flatten a directory structure
var fltn = function(d, p, t, o) {
    for(var k in d){
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8) t[n] = [
            val,
            op
        ];
        else {
            t[n += '/'] = [
                new u8(0),
                op
            ];
            fltn(val, n, t, o);
        }
    }
};
// text encoder
var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, {
        stream: true
    });
    tds = 1;
} catch (e) {}
// decode UTF8
var dutf8 = function(d) {
    for(var r = '', i = 0;;){
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length) return {
            s: r,
            r: slc(d, i - 1)
        };
        if (!eb) r += String.fromCharCode(c);
        else if (eb == 3) {
            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
};
/**
 * Streaming UTF-8 decoding
 */ var DecodeUTF8 = function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */ function DecodeUTF8(cb) {
        this.ondata = cb;
        if (tds) this.t = new TextDecoder();
        else this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ DecodeUTF8.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        final = !!final;
        if (this.t) {
            this.ondata(this.t.decode(chunk, {
                stream: true
            }), final);
            if (final) {
                if (this.t.decode().length) err(8);
                this.t = null;
            }
            return;
        }
        if (!this.p) err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (final) {
            if (r.length) err(8);
            this.p = null;
        } else this.p = r;
        this.ondata(s, final);
    };
    return DecodeUTF8;
}();
;
/**
 * Streaming UTF-8 encoding
 */ var EncodeUTF8 = function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */ function EncodeUTF8(cb) {
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */ EncodeUTF8.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        if (this.d) err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
    };
    return EncodeUTF8;
}();
;
function strToU8(str, latin1) {
    if (latin1) {
        var ar_1 = new u8(str.length);
        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);
        return ar_1;
    }
    if (te) return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function(v) {
        ar[ai++] = v;
    };
    for(var i = 0; i < l; ++i){
        if (ai + 5 > ar.length) {
            var n = new u8(ai + 8 + (l - i << 1));
            n.set(ar);
            ar = n;
        }
        var c = str.charCodeAt(i);
        if (c < 128 || latin1) w(c);
        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
    }
    return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
    if (latin1) {
        var r = '';
        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
        return r;
    } else if (td) {
        return td.decode(dat);
    } else {
        var _a = dutf8(dat), s = _a.s, r = _a.r;
        if (r.length) err(8);
        return s;
    }
}
;
// deflate bit flag
var dbf = function(l) {
    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
// skip local zip header
var slzh = function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
// read zip header
var zh = function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [
        bs,
        b4(d, b + 24),
        b4(d, b + 42)
    ], sc = _a[0], su = _a[1], off = _a[2];
    return [
        b2(d, b + 10),
        sc,
        su,
        fn,
        es + b2(d, b + 30) + b2(d, b + 32),
        off
    ];
};
// read zip64 extra field
var z64e = function(d, b) {
    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));
    return [
        b8(d, b + 12),
        b8(d, b + 4),
        b8(d, b + 20)
    ];
};
// extra field length
var exfl = function(ex) {
    var le = 0;
    if (ex) {
        for(var k in ex){
            var l = ex[k].length;
            if (l > 65535) err(9);
            le += l + 4;
        }
    }
    return le;
};
// write zip header
var wzh = function(d, b, f, fn, u, c, ce, co) {
    var fl = fn.length, ex = f.extra, col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null) d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119) err(10);
    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
    if (c != -1) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) {
        for(var k in ex){
            var exf = ex[k], l = exf.length;
            wbytes(d, b, +k);
            wbytes(d, b + 2, l);
            d.set(exf, b + 4), b += 4 + l;
        }
    }
    if (col) d.set(co, b), b += col;
    return b;
};
// write zip footer (end of central directory)
var wzf = function(o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */ var ZipPassThrough = function() {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */ function ZipPassThrough(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.push = function(chunk, final) {
        if (!this.ondata) err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final) this.crc = this.c.d();
        this.process(chunk, final || false);
    };
    return ZipPassThrough;
}();
;
// I don't extend because TypeScript extension adds 1kB of runtime bloat
/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */ var ZipDeflate = function() {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function ZipDeflate(filename, opts) {
        var _this = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
            _this.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function(chunk, final) {
        try {
            this.d.push(chunk, final);
        } catch (e) {
            this.ondata(e, null, final);
        }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipDeflate.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return ZipDeflate;
}();
;
/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */ var AsyncZipDeflate = function() {
    /**
     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function AsyncZipDeflate(filename, opts) {
        var _this = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err, dat, final) {
            _this.ondata(err, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncZipDeflate.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return AsyncZipDeflate;
}();
;
// TODO: Better tree shaking
/**
 * A zippable archive to which files can incrementally be added
 */ var Zip = function() {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */ function Zip(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */ Zip.prototype.add = function(file) {
        var _this = this;
        if (!this.ondata) err(5);
        // finishing or finished
        if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
            var f = strToU8(file.filename), fl_1 = f.length;
            var com = file.comment, o = com && strToU8(com);
            var u = fl_1 != file.filename.length || o && com.length != o.length;
            var hl_1 = fl_1 + exfl(file.extra) + 30;
            if (fl_1 > 65535) this.ondata(err(11, 0, 1), null, false);
            var header = new u8(hl_1);
            wzh(header, 0, file, f, u, -1);
            var chks_1 = [
                header
            ];
            var pAll_1 = function() {
                for(var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++){
                    var chk = chks_2[_i];
                    _this.ondata(null, chk, false);
                }
                chks_1 = [];
            };
            var tr_1 = this.d;
            this.d = 0;
            var ind_1 = this.u.length;
            var uf_1 = mrg(file, {
                f: f,
                u: u,
                o: o,
                t: function() {
                    if (file.terminate) file.terminate();
                },
                r: function() {
                    pAll_1();
                    if (tr_1) {
                        var nxt = _this.u[ind_1 + 1];
                        if (nxt) nxt.r();
                        else _this.d = 1;
                    }
                    tr_1 = 1;
                }
            });
            var cl_1 = 0;
            file.ondata = function(err, dat, final) {
                if (err) {
                    _this.ondata(err, dat, final);
                    _this.terminate();
                } else {
                    cl_1 += dat.length;
                    chks_1.push(dat);
                    if (final) {
                        var dd = new u8(16);
                        wbytes(dd, 0, 0x8074B50);
                        wbytes(dd, 4, file.crc);
                        wbytes(dd, 8, cl_1);
                        wbytes(dd, 12, file.size);
                        chks_1.push(dd);
                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                        if (tr_1) uf_1.r();
                        tr_1 = 1;
                    } else if (tr_1) pAll_1();
                }
            };
            this.u.push(uf_1);
        }
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */ Zip.prototype.end = function() {
        var _this = this;
        if (this.d & 2) {
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
            return;
        }
        if (this.d) this.e();
        else this.u.push({
            r: function() {
                if (!(_this.d & 1)) return;
                _this.u.splice(-1, 1);
                _this.e();
            },
            t: function() {}
        });
        this.d = 3;
    };
    Zip.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for(var _b = 0, _c = this.u; _b < _c.length; _b++){
            var f = _c[_b];
            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */ Zip.prototype.terminate = function() {
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            f.t();
        }
        this.d = 2;
    };
    return Zip;
}();
;
function zip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length, o = 0, tot = 0;
    var slft = lft, files = new Array(lft);
    var term = [];
    var tAll = function() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var cbd = function(a, b) {
        mt(function() {
            cb(a, b);
        });
    };
    mt(function() {
        cbd = cb;
    });
    var cbf = function() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for(var i = 0; i < slft; ++i){
            var f = files[i];
            try {
                var l = f.c.length;
                wzh(out, tot, f, f.f, f.u, l);
                var badd = 30 + f.f.length + exfl(f.extra);
                var loc = tot + badd;
                out.set(f.c, loc);
                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
            } catch (e) {
                return cbd(e, null);
            }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
    };
    if (!lft) cbf();
    var _loop_1 = function(i) {
        var fn = k[i];
        var _a = r[fn], file = _a[0], p = _a[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function(e, d) {
            if (e) {
                tAll();
                cbd(e, null);
            } else {
                var l = d.length;
                files[i] = mrg(p, {
                    size: size,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || m && com.length != ms,
                    compression: compression
                });
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                if (!--lft) cbf();
            }
        };
        if (s > 65535) cbl(err(11, 0, 1), null);
        if (!compression) cbl(null, file);
        else if (size < 160000) {
            try {
                cbl(null, deflateSync(file, p));
            } catch (e) {
                cbl(e, null);
            }
        } else term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for(var i = 0; i < slft; ++i){
        _loop_1(i);
    }
    return tAll;
}
function zipSync(data, opts) {
    if (!opts) opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for(var fn in r){
        var _a = r[fn], file = _a[0], p = _a[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535) err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
            size: file.length,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || m && com.length != ms,
            o: o,
            compression: compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22), oe = o, cdl = tot - o;
    for(var i = 0; i < files.length; ++i){
        var f = files[i];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */ var UnzipPassThrough = function() {
    function UnzipPassThrough() {}
    UnzipPassThrough.prototype.push = function(data, final) {
        this.ondata(null, data, final);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
}();
;
/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */ var UnzipInflate = function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function UnzipInflate() {
        var _this = this;
        this.i = new Inflate(function(dat, final) {
            _this.ondata(null, dat, final);
        });
    }
    UnzipInflate.prototype.push = function(data, final) {
        try {
            this.i.push(data, final);
        } catch (e) {
            this.ondata(e, null, final);
        }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
}();
;
/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */ var AsyncUnzipInflate = function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function AsyncUnzipInflate(_, sz) {
        var _this = this;
        if (sz < 320000) {
            this.i = new Inflate(function(dat, final) {
                _this.ondata(null, dat, final);
            });
        } else {
            this.i = new AsyncInflate(function(err, dat, final) {
                _this.ondata(err, dat, final);
            });
            this.terminate = this.i.terminate;
        }
    }
    AsyncUnzipInflate.prototype.push = function(data, final) {
        if (this.i.terminate) data = slc(data, 0);
        this.i.push(data, final);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
}();
;
/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */ var Unzip = function() {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */ function Unzip(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
            0: UnzipPassThrough
        };
        this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzip.prototype.push = function(chunk, final) {
        var _this = this;
        if (!this.onfile) err(5);
        if (!this.p) err(4);
        if (this.c > 0) {
            var len = Math.min(this.c, chunk.length);
            var toAdd = chunk.subarray(0, len);
            this.c -= len;
            if (this.d) this.d.push(toAdd, !this.c);
            else this.k[0].push(toAdd);
            chunk = chunk.subarray(len);
            if (chunk.length) return this.push(chunk, final);
        } else {
            var f = 0, i = 0, is = void 0, buf = void 0;
            if (!this.p.length) buf = chunk;
            else if (!chunk.length) buf = this.p;
            else {
                buf = new u8(this.p.length + chunk.length);
                buf.set(this.p), buf.set(chunk, this.p.length);
            }
            var l = buf.length, oc = this.c, add = oc && this.d;
            var _loop_2 = function() {
                var _a;
                var sig = b4(buf, i);
                if (sig == 0x4034B50) {
                    f = 1, is = i;
                    this_1.d = null;
                    this_1.c = 0;
                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                    if (l > i + 30 + fnl + es) {
                        var chks_3 = [];
                        this_1.k.unshift(chks_3);
                        f = 2;
                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                        if (sc_1 == 4294967295) {
                            _a = dd ? [
                                -2
                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                        } else if (dd) sc_1 = -1;
                        i += es;
                        this_1.c = sc_1;
                        var d_1;
                        var file_1 = {
                            name: fn_1,
                            compression: cmp_1,
                            start: function() {
                                if (!file_1.ondata) err(5);
                                if (!sc_1) file_1.ondata(null, et, true);
                                else {
                                    var ctr = _this.o[cmp_1];
                                    if (!ctr) file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);
                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                    d_1.ondata = function(err, dat, final) {
                                        file_1.ondata(err, dat, final);
                                    };
                                    for(var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++){
                                        var dat = chks_4[_i];
                                        d_1.push(dat, false);
                                    }
                                    if (_this.k[0] == chks_3 && _this.c) _this.d = d_1;
                                    else d_1.push(et, true);
                                }
                            },
                            terminate: function() {
                                if (d_1 && d_1.terminate) d_1.terminate();
                            }
                        };
                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
                        this_1.onfile(file_1);
                    }
                    return "break";
                } else if (oc) {
                    if (sig == 0x8074B50) {
                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                        return "break";
                    } else if (sig == 0x2014B50) {
                        is = i -= 4, f = 3, this_1.c = 0;
                        return "break";
                    }
                }
            };
            var this_1 = this;
            for(; i < l - 4; ++i){
                var state_1 = _loop_2();
                if (state_1 === "break") break;
            }
            this.p = et;
            if (oc < 0) {
                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
                if (add) add.push(dat, !!f);
                else this.k[+(f == 2)].push(dat);
            }
            if (f & 2) return this.push(buf.subarray(i), final);
            this.p = buf.subarray(i);
        }
        if (final) {
            if (this.c) err(13);
            this.p = null;
        }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */ Unzip.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
    };
    return Unzip;
}();
;
var mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function(fn) {
    fn();
};
function unzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') err(7);
    var term = [];
    var tAll = function() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var files = {};
    var cbd = function(a, b) {
        mt(function() {
            cb(a, b);
        });
    };
    mt(function() {
        cbd = cb;
    });
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e){
        if (!e || data.length - e > 65558) {
            cbd(err(13, 0, 1), null);
            return tAll;
        }
    }
    ;
    var lft = b2(data, e + 8);
    if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295 || c == 65535;
        if (z) {
            var ze = b4(data, e - 12);
            z = b4(data, ze) == 0x6064B50;
            if (z) {
                c = lft = b4(data, ze + 32);
                o = b4(data, ze + 48);
            }
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function(i) {
            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
            o = no;
            var cbl = function(e, d) {
                if (e) {
                    tAll();
                    cbd(e, null);
                } else {
                    if (d) files[fn] = d;
                    if (!--lft) cbd(null, files);
                }
            };
            if (!fltr || fltr({
                name: fn,
                size: sc,
                originalSize: su,
                compression: c_1
            })) {
                if (!c_1) cbl(null, slc(data, b, b + sc));
                else if (c_1 == 8) {
                    var infl = data.subarray(b, b + sc);
                    // Synchronously decompress under 512KB, or barely-compressed data
                    if (su < 524288 || sc > 0.8 * su) {
                        try {
                            cbl(null, inflateSync(infl, {
                                out: new u8(su)
                            }));
                        } catch (e) {
                            cbl(e, null);
                        }
                    } else term.push(inflate(infl, {
                        size: su
                    }, cbl));
                } else cbl(err(14, 'unknown compression type ' + c_1, 1), null);
            } else cbl(null, null);
        };
        for(var i = 0; i < c; ++i){
            _loop_3(i);
        }
    } else cbd(null, {});
    return tAll;
}
function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e){
        if (!e || data.length - e > 65558) err(13);
    }
    ;
    var c = b2(data, e + 8);
    if (!c) return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
        var ze = b4(data, e - 12);
        z = b4(data, ze) == 0x6064B50;
        if (z) {
            c = b4(data, ze + 32);
            o = b4(data, ze + 48);
        }
    }
    var fltr = opts && opts.filter;
    for(var i = 0; i < c; ++i){
        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_2
        })) {
            if (!c_2) files[fn] = slc(data, b, b + sc);
            else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), {
                out: new u8(su)
            });
            else err(14, 'unknown compression type ' + c_2);
        }
    }
    return files;
}
}),
"[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/browser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || ("TURBOPACK compile-time value", "undefined") !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let flagForceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    flagForceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    flagForceColor = 1;
}
function envForceColor() {
    if ('FORCE_COLOR' in env) {
        if (env.FORCE_COLOR === 'true') {
            return 1;
        }
        if (env.FORCE_COLOR === 'false') {
            return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
        flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
        return 0;
    }
    if (sniffFlags) {
        if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
            return 3;
        }
        if (hasFlag('color=256')) {
            return 2;
        }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE',
            'DRONE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    });
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({
        isTTY: tty.isatty(1)
    }),
    stderr: getSupportLevel({
        isTTY: tty.isatty(2)
    })
};
}),
"[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/ZipToken.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Ref https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
 */ __turbopack_context__.s([
    "DataDescriptor",
    ()=>DataDescriptor,
    "EndOfCentralDirectoryRecordToken",
    ()=>EndOfCentralDirectoryRecordToken,
    "FileHeader",
    ()=>FileHeader,
    "LocalFileHeaderToken",
    ()=>LocalFileHeaderToken,
    "Signature",
    ()=>Signature
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
;
const Signature = {
    LocalFileHeader: 0x04034b50,
    DataDescriptor: 0x08074b50,
    CentralFileHeader: 0x02014b50,
    EndOfCentralDirectory: 0x06054b50
};
const DataDescriptor = {
    get (array) {
        return {
            signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 0),
            compressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 8),
            uncompressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 12)
        };
    },
    len: 16
};
const LocalFileHeaderToken = {
    get (array) {
        const flags = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 6);
        return {
            signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 0),
            minVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 4),
            dataDescriptor: !!(flags & 0x0008),
            compressedMethod: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 8),
            compressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 18),
            uncompressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 22),
            filenameLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 26),
            extraFieldLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 28),
            filename: null
        };
    },
    len: 30
};
const EndOfCentralDirectoryRecordToken = {
    get (array) {
        return {
            signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 0),
            nrOfThisDisk: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 4),
            nrOfThisDiskWithTheStart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 6),
            nrOfEntriesOnThisDisk: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 8),
            nrOfEntriesOfSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 10),
            sizeOfCd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 12),
            offsetOfStartOfCd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 16),
            zipFileCommentLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 20)
        };
    },
    len: 22
};
const FileHeader = {
    get (array) {
        const flags = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 8);
        return {
            signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 0),
            minVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 6),
            dataDescriptor: !!(flags & 0x0008),
            compressedMethod: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 10),
            compressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 20),
            uncompressedSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 24),
            filenameLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 28),
            extraFieldLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 30),
            fileCommentLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"].get(array, 32),
            relativeOffsetOfLocalHeader: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].get(array, 42),
            filename: null
        };
    },
    len: 46
};
}),
"[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/ZipHandler.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ZipHandler",
    ()=>ZipHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fflate$40$0$2e$8$2e$2$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3_supports$2d$color$40$8$2e$1$2e$1$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/ZipToken.js [app-route] (ecmascript)");
;
;
;
;
function signatureToArray(signature) {
    const signatureBytes = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].len);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"].put(signatureBytes, 0, signature);
    return signatureBytes;
}
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$debug$40$4$2e$4$2e$3_supports$2d$color$40$8$2e$1$2e$1$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('tokenizer:inflate');
const syncBufferSize = 256 * 1024;
const ddSignatureArray = signatureToArray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].DataDescriptor);
const eocdSignatureBytes = signatureToArray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].EndOfCentralDirectory);
class ZipHandler {
    constructor(tokenizer){
        this.tokenizer = tokenizer;
        this.syncBuffer = new Uint8Array(syncBufferSize);
    }
    async isZip() {
        return await this.peekSignature() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].LocalFileHeader;
    }
    peekSignature() {
        return this.tokenizer.peekToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"]);
    }
    async findEndOfCentralDirectoryLocator() {
        const randomReadTokenizer = this.tokenizer;
        const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
        const buffer = this.syncBuffer.subarray(0, chunkLength);
        await this.tokenizer.readBuffer(buffer, {
            position: randomReadTokenizer.fileInfo.size - chunkLength
        });
        // Search the buffer from end to beginning for EOCD signature
        // const signature = 0x06054b50;
        for(let i = buffer.length - 4; i >= 0; i--){
            // Compare 4 bytes directly without calling readUInt32LE
            if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
                return randomReadTokenizer.fileInfo.size - chunkLength + i;
            }
        }
        return -1;
    }
    async readCentralDirectory() {
        if (!this.tokenizer.supportsRandomAccess()) {
            debug('Cannot reading central-directory without random-read support');
            return;
        }
        debug('Reading central-directory...');
        const pos = this.tokenizer.position;
        const offset = await this.findEndOfCentralDirectoryLocator();
        if (offset > 0) {
            debug('Central-directory 32-bit signature found');
            const eocdHeader = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfCentralDirectoryRecordToken"], offset);
            const files = [];
            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
            for(let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n){
                const entry = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileHeader"]);
                if (entry.signature !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].CentralFileHeader) {
                    throw new Error('Expected Central-File-Header signature');
                }
                entry.filename = await this.tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](entry.filenameLength, 'utf-8'));
                await this.tokenizer.ignore(entry.extraFieldLength);
                await this.tokenizer.ignore(entry.fileCommentLength);
                files.push(entry);
                debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
            }
            this.tokenizer.setPosition(pos);
            return files;
        }
        this.tokenizer.setPosition(pos);
    }
    async unzip(fileCb) {
        const entries = await this.readCentralDirectory();
        if (entries) {
            // Use Central Directory to iterate over files
            return this.iterateOverCentralDirectory(entries, fileCb);
        }
        // Scan Zip files for local-file-header
        let stop = false;
        do {
            const zipHeader = await this.readLocalFileHeader();
            if (!zipHeader) break;
            const next = fileCb(zipHeader);
            stop = !!next.stop;
            let fileData = undefined;
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
                const chunks = [];
                let len = syncBufferSize;
                debug('Compressed-file-size unknown, scanning for next data-descriptor-signature....');
                let nextHeaderIndex = -1;
                while(nextHeaderIndex < 0 && len === syncBufferSize){
                    len = await this.tokenizer.peekBuffer(this.syncBuffer, {
                        mayBeLess: true
                    });
                    nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
                    const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
                    if (next.handler) {
                        const data = new Uint8Array(size);
                        await this.tokenizer.readBuffer(data);
                        chunks.push(data);
                    } else {
                        // Move position to the next header if found, skip the whole buffer otherwise
                        await this.tokenizer.ignore(size);
                    }
                }
                debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
                if (next.handler) {
                    await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
                }
            } else {
                if (next.handler) {
                    debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
                    fileData = new Uint8Array(zipHeader.compressedSize);
                    await this.tokenizer.readBuffer(fileData);
                    await this.inflate(zipHeader, fileData, next.handler);
                } else {
                    debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
                    await this.tokenizer.ignore(zipHeader.compressedSize);
                }
            }
            debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
            if (zipHeader.dataDescriptor) {
                // await this.tokenizer.ignore(DataDescriptor.len);
                const dataDescriptor = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DataDescriptor"]);
                if (dataDescriptor.signature !== 0x08074b50) {
                    throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DataDescriptor"].len}`);
                }
            }
        }while (!stop)
    }
    async iterateOverCentralDirectory(entries, fileCb) {
        for (const fileHeader of entries){
            const next = fileCb(fileHeader);
            if (next.handler) {
                this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
                const zipHeader = await this.readLocalFileHeader();
                if (zipHeader) {
                    await this.tokenizer.ignore(zipHeader.extraFieldLength);
                    const fileData = new Uint8Array(fileHeader.compressedSize);
                    await this.tokenizer.readBuffer(fileData);
                    await this.inflate(zipHeader, fileData, next.handler);
                }
            }
            if (next.stop) break;
        }
    }
    inflate(zipHeader, fileData, cb) {
        if (zipHeader.compressedMethod === 0) {
            return cb(fileData);
        }
        debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
        const uncompressedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fflate$40$0$2e$8$2e$2$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decompressSync"])(fileData);
        return cb(uncompressedData);
    }
    async readLocalFileHeader() {
        const signature = await this.tokenizer.peekToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"]);
        if (signature === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].LocalFileHeader) {
            const header = await this.tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LocalFileHeaderToken"]);
            header.filename = await this.tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](header.filenameLength, 'utf-8'));
            return header;
        }
        if (signature === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipToken$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Signature"].CentralFileHeader) {
            return false;
        }
        if (signature === 0xE011CFD0) {
            throw new Error('Encrypted ZIP');
        }
        throw new Error('Unexpected signature');
    }
}
function indexOf(buffer, portion) {
    const bufferLength = buffer.length;
    const portionLength = portion.length;
    // Return -1 if the portion is longer than the buffer
    if (portionLength > bufferLength) return -1;
    // Search for the portion in the buffer
    for(let i = 0; i <= bufferLength - portionLength; i++){
        let found = true;
        for(let j = 0; j < portionLength; j++){
            if (buffer[i + j] !== portion[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            return i; // Return the starting offset
        }
    }
    return -1; // Not found
}
function mergeArrays(chunks) {
    // Concatenate chunks into a single Uint8Array
    const totalLength = chunks.reduce((acc, curr)=>acc + curr.length, 0);
    const mergedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks){
        mergedArray.set(chunk, offset);
        offset += chunk.length;
    }
    return mergedArray;
}
}),
"[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/GzipHandler.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GzipHandler",
    ()=>GzipHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fflate$40$0$2e$8$2e$2$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/fflate@0.8.2/node_modules/fflate/esm/index.mjs [app-route] (ecmascript)");
;
class GzipHandler {
    constructor(tokenizer){
        this.gunzip = undefined;
        this.tokenizer = tokenizer;
    }
    inflate() {
        let done = false;
        let cancelled = false;
        const parent = this;
        return new ReadableStream({
            start: (controller)=>{
                parent.gunzip = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fflate$40$0$2e$8$2e$2$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncGunzip"]((err, chunk, final)=>{
                    if (err) {
                        controller.error(err);
                        return;
                    }
                    if (chunk && !cancelled) {
                        controller.enqueue(chunk);
                    }
                    if (final && !cancelled) {
                        controller.close();
                        parent.gunzip.terminate();
                    }
                });
            },
            async pull (controller) {
                const chunkSize = 1024;
                try {
                    const buffer = new Uint8Array(chunkSize);
                    const size = await parent.tokenizer.readBuffer(buffer, {
                        mayBeLess: true
                    });
                    if (size === 0) {
                        if (!done) {
                            done = true;
                            if (!cancelled) {
                                parent.gunzip.push(new Uint8Array(0), true);
                            }
                        }
                        return;
                    }
                    parent.gunzip.push(buffer.subarray(0, size), false);
                } catch (err) {
                    controller.error(err);
                }
            },
            cancel: ()=>{
                parent.gunzip.terminate();
                cancelled = true;
            }
        });
    }
}
}),
"[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/ZipHandler.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$GzipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/GzipHandler.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/.pnpm/uint8array-extras@1.5.0/node_modules/uint8array-extras/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "areUint8ArraysEqual",
    ()=>areUint8ArraysEqual,
    "assertUint8Array",
    ()=>assertUint8Array,
    "assertUint8ArrayOrArrayBuffer",
    ()=>assertUint8ArrayOrArrayBuffer,
    "base64ToString",
    ()=>base64ToString,
    "base64ToUint8Array",
    ()=>base64ToUint8Array,
    "compareUint8Arrays",
    ()=>compareUint8Arrays,
    "concatUint8Arrays",
    ()=>concatUint8Arrays,
    "getUintBE",
    ()=>getUintBE,
    "hexToUint8Array",
    ()=>hexToUint8Array,
    "includes",
    ()=>includes,
    "indexOf",
    ()=>indexOf,
    "isUint8Array",
    ()=>isUint8Array,
    "stringToBase64",
    ()=>stringToBase64,
    "stringToUint8Array",
    ()=>stringToUint8Array,
    "toUint8Array",
    ()=>toUint8Array,
    "uint8ArrayToBase64",
    ()=>uint8ArrayToBase64,
    "uint8ArrayToHex",
    ()=>uint8ArrayToHex,
    "uint8ArrayToString",
    ()=>uint8ArrayToString
]);
const objectToString = Object.prototype.toString;
const uint8ArrayStringified = '[object Uint8Array]';
const arrayBufferStringified = '[object ArrayBuffer]';
function isType(value, typeConstructor, typeStringified) {
    if (!value) {
        return false;
    }
    if (value.constructor === typeConstructor) {
        return true;
    }
    return objectToString.call(value) === typeStringified;
}
function isUint8Array(value) {
    return isType(value, Uint8Array, uint8ArrayStringified);
}
function isArrayBuffer(value) {
    return isType(value, ArrayBuffer, arrayBufferStringified);
}
function isUint8ArrayOrArrayBuffer(value) {
    return isUint8Array(value) || isArrayBuffer(value);
}
function assertUint8Array(value) {
    if (!isUint8Array(value)) {
        throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
    }
}
function assertUint8ArrayOrArrayBuffer(value) {
    if (!isUint8ArrayOrArrayBuffer(value)) {
        throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value}\``);
    }
}
function toUint8Array(value) {
    if (value instanceof ArrayBuffer) {
        return new Uint8Array(value);
    }
    if (ArrayBuffer.isView(value)) {
        return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }
    throw new TypeError(`Unsupported value, got \`${typeof value}\`.`);
}
function concatUint8Arrays(arrays, totalLength) {
    if (arrays.length === 0) {
        return new Uint8Array(0);
    }
    totalLength ??= arrays.reduce((accumulator, currentValue)=>accumulator + currentValue.length, 0);
    const returnValue = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays){
        assertUint8Array(array);
        returnValue.set(array, offset);
        offset += array.length;
    }
    return returnValue;
}
function areUint8ArraysEqual(a, b) {
    assertUint8Array(a);
    assertUint8Array(b);
    if (a === b) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    // eslint-disable-next-line unicorn/no-for-loop
    for(let index = 0; index < a.length; index++){
        if (a[index] !== b[index]) {
            return false;
        }
    }
    return true;
}
function compareUint8Arrays(a, b) {
    assertUint8Array(a);
    assertUint8Array(b);
    const length = Math.min(a.length, b.length);
    for(let index = 0; index < length; index++){
        const diff = a[index] - b[index];
        if (diff !== 0) {
            return Math.sign(diff);
        }
    }
    // At this point, all the compared elements are equal.
    // The shorter array should come first if the arrays are of different lengths.
    return Math.sign(a.length - b.length);
}
const cachedDecoders = {
    utf8: new globalThis.TextDecoder('utf8')
};
function uint8ArrayToString(array, encoding = 'utf8') {
    assertUint8ArrayOrArrayBuffer(array);
    cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
    return cachedDecoders[encoding].decode(array);
}
function assertString(value) {
    if (typeof value !== 'string') {
        throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
    }
}
const cachedEncoder = new globalThis.TextEncoder();
function stringToUint8Array(string) {
    assertString(string);
    return cachedEncoder.encode(string);
}
function base64ToBase64Url(base64) {
    return base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');
}
function base64UrlToBase64(base64url) {
    const base64 = base64url.replaceAll('-', '+').replaceAll('_', '/');
    const padding = (4 - base64.length % 4) % 4;
    return base64 + '='.repeat(padding);
}
// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/
// Important: Keep this value divisible by 3 so intermediate chunks produce no Base64 padding.
const MAX_BLOCK_SIZE = 65_535;
function uint8ArrayToBase64(array, { urlSafe = false } = {}) {
    assertUint8Array(array);
    let base64 = '';
    for(let index = 0; index < array.length; index += MAX_BLOCK_SIZE){
        const chunk = array.subarray(index, index + MAX_BLOCK_SIZE);
        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
        base64 += globalThis.btoa(String.fromCodePoint.apply(undefined, chunk));
    }
    return urlSafe ? base64ToBase64Url(base64) : base64;
}
function base64ToUint8Array(base64String) {
    assertString(base64String);
    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), (x)=>x.codePointAt(0));
}
function stringToBase64(string, { urlSafe = false } = {}) {
    assertString(string);
    return uint8ArrayToBase64(stringToUint8Array(string), {
        urlSafe
    });
}
function base64ToString(base64String) {
    assertString(base64String);
    return uint8ArrayToString(base64ToUint8Array(base64String));
}
const byteToHexLookupTable = Array.from({
    length: 256
}, (_, index)=>index.toString(16).padStart(2, '0'));
function uint8ArrayToHex(array) {
    assertUint8Array(array);
    // Concatenating a string is faster than using an array.
    let hexString = '';
    // eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.
    for(let index = 0; index < array.length; index++){
        hexString += byteToHexLookupTable[array[index]];
    }
    return hexString;
}
const hexToDecimalLookupTable = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
};
function hexToUint8Array(hexString) {
    assertString(hexString);
    if (hexString.length % 2 !== 0) {
        throw new Error('Invalid Hex string length.');
    }
    const resultLength = hexString.length / 2;
    const bytes = new Uint8Array(resultLength);
    for(let index = 0; index < resultLength; index++){
        const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
        const lowNibble = hexToDecimalLookupTable[hexString[index * 2 + 1]];
        if (highNibble === undefined || lowNibble === undefined) {
            throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
        }
        bytes[index] = highNibble << 4 | lowNibble; // eslint-disable-line no-bitwise
    }
    return bytes;
}
function getUintBE(view) {
    const { byteLength } = view;
    if (byteLength === 6) {
        return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
    }
    if (byteLength === 5) {
        return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
    }
    if (byteLength === 4) {
        return view.getUint32(0);
    }
    if (byteLength === 3) {
        return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
    }
    if (byteLength === 2) {
        return view.getUint16(0);
    }
    if (byteLength === 1) {
        return view.getUint8(0);
    }
}
function indexOf(array, value) {
    const arrayLength = array.length;
    const valueLength = value.length;
    if (valueLength === 0) {
        return -1;
    }
    if (valueLength > arrayLength) {
        return -1;
    }
    const validOffsetLength = arrayLength - valueLength;
    for(let index = 0; index <= validOffsetLength; index++){
        let isMatch = true;
        for(let index2 = 0; index2 < valueLength; index2++){
            if (array[index + index2] !== value[index2]) {
                isMatch = false;
                break;
            }
        }
        if (isMatch) {
            return index;
        }
    }
    return -1;
}
function includes(array, value) {
    return indexOf(array, value) !== -1;
}
}),
"[project]/node_modules/.pnpm/file-type@21.1.0/node_modules/file-type/util.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringToBytes",
    ()=>stringToBytes,
    "tarHeaderChecksumMatches",
    ()=>tarHeaderChecksumMatches,
    "uint32SyncSafeToken",
    ()=>uint32SyncSafeToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
;
function stringToBytes(string, encoding) {
    if (encoding === 'utf-16le') {
        const bytes = [];
        for(let index = 0; index < string.length; index++){
            const code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point
            bytes.push(code & 0xFF, code >> 8 & 0xFF); // High byte
        }
        return bytes;
    }
    if (encoding === 'utf-16be') {
        const bytes = [];
        for(let index = 0; index < string.length; index++){
            const code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point
            bytes.push(code >> 8 & 0xFF, code & 0xFF); // Low byte
        }
        return bytes;
    }
    return [
        ...string
    ].map((character)=>character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
    const readSum = Number.parseInt(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](6).get(arrayBuffer, 148).replace(/\0.*$/, '').trim(), 8); // Read sum in header
    if (Number.isNaN(readSum)) {
        return false;
    }
    let sum = 8 * 0x20; // Initialize signed bit sum
    for(let index = offset; index < offset + 148; index++){
        sum += arrayBuffer[index];
    }
    for(let index = offset + 156; index < offset + 512; index++){
        sum += arrayBuffer[index];
    }
    return readSum === sum;
}
const uint32SyncSafeToken = {
    get: (buffer, offset)=>buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
};
}),
"[project]/node_modules/.pnpm/file-type@21.1.0/node_modules/file-type/supported.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extensions",
    ()=>extensions,
    "mimeTypes",
    ()=>mimeTypes
]);
const extensions = [
    'jpg',
    'png',
    'apng',
    'gif',
    'webp',
    'flif',
    'xcf',
    'cr2',
    'cr3',
    'orf',
    'arw',
    'dng',
    'nef',
    'rw2',
    'raf',
    'tif',
    'bmp',
    'icns',
    'jxr',
    'psd',
    'indd',
    'zip',
    'tar',
    'rar',
    'gz',
    'bz2',
    '7z',
    'dmg',
    'mp4',
    'mid',
    'mkv',
    'webm',
    'mov',
    'avi',
    'mpg',
    'mp2',
    'mp3',
    'm4a',
    'oga',
    'ogg',
    'ogv',
    'opus',
    'flac',
    'wav',
    'spx',
    'amr',
    'pdf',
    'epub',
    'elf',
    'macho',
    'exe',
    'swf',
    'rtf',
    'wasm',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'otf',
    'ttc',
    'ico',
    'flv',
    'ps',
    'xz',
    'sqlite',
    'nes',
    'crx',
    'xpi',
    'cab',
    'deb',
    'ar',
    'rpm',
    'Z',
    'lz',
    'cfb',
    'mxf',
    'mts',
    'blend',
    'bpg',
    'docx',
    'pptx',
    'xlsx',
    '3gp',
    '3g2',
    'j2c',
    'jp2',
    'jpm',
    'jpx',
    'mj2',
    'aif',
    'qcp',
    'odt',
    'ods',
    'odp',
    'xml',
    'mobi',
    'heic',
    'cur',
    'ktx',
    'ape',
    'wv',
    'dcm',
    'ics',
    'glb',
    'pcap',
    'dsf',
    'lnk',
    'alias',
    'voc',
    'ac3',
    'm4v',
    'm4p',
    'm4b',
    'f4v',
    'f4p',
    'f4b',
    'f4a',
    'mie',
    'asf',
    'ogm',
    'ogx',
    'mpc',
    'arrow',
    'shp',
    'aac',
    'mp1',
    'it',
    's3m',
    'xm',
    'skp',
    'avif',
    'eps',
    'lzh',
    'pgp',
    'asar',
    'stl',
    'chm',
    '3mf',
    'zst',
    'jxl',
    'vcf',
    'jls',
    'pst',
    'dwg',
    'parquet',
    'class',
    'arj',
    'cpio',
    'ace',
    'avro',
    'icc',
    'fbx',
    'vsdx',
    'vtt',
    'apk',
    'drc',
    'lz4',
    'potx',
    'xltx',
    'dotx',
    'xltm',
    'ott',
    'ots',
    'otp',
    'odg',
    'otg',
    'xlsm',
    'docm',
    'dotm',
    'potm',
    'pptm',
    'jar',
    'rm',
    'ppsm',
    'ppsx',
    'tar.gz',
    'reg',
    'dat'
];
const mimeTypes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/flif',
    'image/x-xcf',
    'image/x-canon-cr2',
    'image/x-canon-cr3',
    'image/tiff',
    'image/bmp',
    'image/vnd.ms-photo',
    'image/vnd.adobe.photoshop',
    'application/x-indesign',
    'application/epub+zip',
    'application/x-xpinstall',
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
    'application/vnd.oasis.opendocument.text',
    'application/vnd.oasis.opendocument.spreadsheet',
    'application/vnd.oasis.opendocument.presentation',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
    'application/zip',
    'application/x-tar',
    'application/x-rar-compressed',
    'application/gzip',
    'application/x-bzip2',
    'application/x-7z-compressed',
    'application/x-apple-diskimage',
    'application/vnd.apache.arrow.file',
    'video/mp4',
    'audio/midi',
    'video/matroska',
    'video/webm',
    'video/quicktime',
    'video/vnd.avi',
    'audio/wav',
    'audio/qcelp',
    'audio/x-ms-asf',
    'video/x-ms-asf',
    'application/vnd.ms-asf',
    'video/mpeg',
    'video/3gpp',
    'audio/mpeg',
    'audio/mp4',
    'video/ogg',
    'audio/ogg',
    'audio/ogg; codecs=opus',
    'application/ogg',
    'audio/flac',
    'audio/ape',
    'audio/wavpack',
    'audio/amr',
    'application/pdf',
    'application/x-elf',
    'application/x-mach-binary',
    'application/x-msdownload',
    'application/x-shockwave-flash',
    'application/rtf',
    'application/wasm',
    'font/woff',
    'font/woff2',
    'application/vnd.ms-fontobject',
    'font/ttf',
    'font/otf',
    'font/collection',
    'image/x-icon',
    'video/x-flv',
    'application/postscript',
    'application/eps',
    'application/x-xz',
    'application/x-sqlite3',
    'application/x-nintendo-nes-rom',
    'application/x-google-chrome-extension',
    'application/vnd.ms-cab-compressed',
    'application/x-deb',
    'application/x-unix-archive',
    'application/x-rpm',
    'application/x-compress',
    'application/x-lzip',
    'application/x-cfb',
    'application/x-mie',
    'application/mxf',
    'video/mp2t',
    'application/x-blender',
    'image/bpg',
    'image/j2c',
    'image/jp2',
    'image/jpx',
    'image/jpm',
    'image/mj2',
    'audio/aiff',
    'application/xml',
    'application/x-mobipocket-ebook',
    'image/heif',
    'image/heif-sequence',
    'image/heic',
    'image/heic-sequence',
    'image/icns',
    'image/ktx',
    'application/dicom',
    'audio/x-musepack',
    'text/calendar',
    'text/vcard',
    'text/vtt',
    'model/gltf-binary',
    'application/vnd.tcpdump.pcap',
    'audio/x-dsf',
    'application/x.ms.shortcut',
    'application/x.apple.alias',
    'audio/x-voc',
    'audio/vnd.dolby.dd-raw',
    'audio/x-m4a',
    'image/apng',
    'image/x-olympus-orf',
    'image/x-sony-arw',
    'image/x-adobe-dng',
    'image/x-nikon-nef',
    'image/x-panasonic-rw2',
    'image/x-fujifilm-raf',
    'video/x-m4v',
    'video/3gpp2',
    'application/x-esri-shape',
    'audio/aac',
    'audio/x-it',
    'audio/x-s3m',
    'audio/x-xm',
    'video/MP1S',
    'video/MP2P',
    'application/vnd.sketchup.skp',
    'image/avif',
    'application/x-lzh-compressed',
    'application/pgp-encrypted',
    'application/x-asar',
    'model/stl',
    'application/vnd.ms-htmlhelp',
    'model/3mf',
    'image/jxl',
    'application/zstd',
    'image/jls',
    'application/vnd.ms-outlook',
    'image/vnd.dwg',
    'application/vnd.apache.parquet',
    'application/java-vm',
    'application/x-arj',
    'application/x-cpio',
    'application/x-ace-compressed',
    'application/avro',
    'application/vnd.iccprofile',
    'application/x.autodesk.fbx',
    'application/vnd.visio',
    'application/vnd.android.package-archive',
    'application/vnd.google.draco',
    'application/x-lz4',
    'application/vnd.openxmlformats-officedocument.presentationml.template',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
    'application/vnd.ms-excel.template.macroenabled.12',
    'application/vnd.oasis.opendocument.text-template',
    'application/vnd.oasis.opendocument.spreadsheet-template',
    'application/vnd.oasis.opendocument.presentation-template',
    'application/vnd.oasis.opendocument.graphics',
    'application/vnd.oasis.opendocument.graphics-template',
    'application/vnd.ms-excel.sheet.macroenabled.12',
    'application/vnd.ms-word.document.macroenabled.12',
    'application/vnd.ms-word.template.macroenabled.12',
    'application/vnd.ms-powerpoint.template.macroenabled.12',
    'application/vnd.ms-powerpoint.presentation.macroenabled.12',
    'application/java-archive',
    'application/vnd.rn-realmedia',
    'application/x-ms-regedit',
    'application/x-ft-windows-registry-hive'
];
}),
"[project]/node_modules/.pnpm/file-type@21.1.0/node_modules/file-type/core.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
Primary entry point, Node.js specific entry point is index.js
*/ __turbopack_context__.s([
    "FileTypeParser",
    ()=>FileTypeParser,
    "fileTypeFromBlob",
    ()=>fileTypeFromBlob,
    "fileTypeFromBuffer",
    ()=>fileTypeFromBuffer,
    "fileTypeFromStream",
    ()=>fileTypeFromStream,
    "fileTypeFromTokenizer",
    ()=>fileTypeFromTokenizer,
    "fileTypeStream",
    ()=>fileTypeStream,
    "reasonableDetectionSizeInBytes",
    ()=>reasonableDetectionSizeInBytes,
    "supportedExtensions",
    ()=>supportedExtensions,
    "supportedMimeTypes",
    ()=>supportedMimeTypes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/core.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@10.3.4/node_modules/strtok3/lib/stream/Errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/ZipHandler.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$GzipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tokenizer+inflate@0.3.1/node_modules/@tokenizer/inflate/lib/GzipHandler.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uint8array-extras@1.5.0/node_modules/uint8array-extras/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/file-type@21.1.0/node_modules/file-type/util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/file-type@21.1.0/node_modules/file-type/supported.js [app-route] (ecmascript)");
;
;
;
;
;
;
const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.
async function fileTypeFromStream(stream, options) {
    return new FileTypeParser(options).fromStream(stream);
}
async function fileTypeFromBuffer(input, options) {
    return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
    return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
    mimeType = mimeType.toLowerCase();
    switch(mimeType){
        case 'application/epub+zip':
            return {
                ext: 'epub',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.text':
            return {
                ext: 'odt',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.text-template':
            return {
                ext: 'ott',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.spreadsheet':
            return {
                ext: 'ods',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.spreadsheet-template':
            return {
                ext: 'ots',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.presentation':
            return {
                ext: 'odp',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.presentation-template':
            return {
                ext: 'otp',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.graphics':
            return {
                ext: 'odg',
                mime: mimeType
            };
        case 'application/vnd.oasis.opendocument.graphics-template':
            return {
                ext: 'otg',
                mime: mimeType
            };
        case 'application/vnd.openxmlformats-officedocument.presentationml.slideshow':
            return {
                ext: 'ppsx',
                mime: mimeType
            };
        case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
            return {
                ext: 'xlsx',
                mime: mimeType
            };
        case 'application/vnd.ms-excel.sheet.macroenabled':
            return {
                ext: 'xlsm',
                mime: 'application/vnd.ms-excel.sheet.macroenabled.12'
            };
        case 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':
            return {
                ext: 'xltx',
                mime: mimeType
            };
        case 'application/vnd.ms-excel.template.macroenabled':
            return {
                ext: 'xltm',
                mime: 'application/vnd.ms-excel.template.macroenabled.12'
            };
        case 'application/vnd.ms-powerpoint.slideshow.macroenabled':
            return {
                ext: 'ppsm',
                mime: 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'
            };
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
            return {
                ext: 'docx',
                mime: mimeType
            };
        case 'application/vnd.ms-word.document.macroenabled':
            return {
                ext: 'docm',
                mime: 'application/vnd.ms-word.document.macroenabled.12'
            };
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':
            return {
                ext: 'dotx',
                mime: mimeType
            };
        case 'application/vnd.ms-word.template.macroenabledtemplate':
            return {
                ext: 'dotm',
                mime: 'application/vnd.ms-word.template.macroenabled.12'
            };
        case 'application/vnd.openxmlformats-officedocument.presentationml.template':
            return {
                ext: 'potx',
                mime: mimeType
            };
        case 'application/vnd.ms-powerpoint.template.macroenabled':
            return {
                ext: 'potm',
                mime: 'application/vnd.ms-powerpoint.template.macroenabled.12'
            };
        case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
            return {
                ext: 'pptx',
                mime: mimeType
            };
        case 'application/vnd.ms-powerpoint.presentation.macroenabled':
            return {
                ext: 'pptm',
                mime: 'application/vnd.ms-powerpoint.presentation.macroenabled.12'
            };
        case 'application/vnd.ms-visio.drawing':
            return {
                ext: 'vsdx',
                mime: 'application/vnd.visio'
            };
        case 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml':
            return {
                ext: '3mf',
                mime: 'model/3mf'
            };
        default:
    }
}
function _check(buffer, headers, options) {
    options = {
        offset: 0,
        ...options
    };
    for (const [index, header] of headers.entries()){
        // If a bitmask is set
        if (options.mask) {
            // If header doesn't equal `buf` with bits masked off
            if (header !== (options.mask[index] & buffer[index + options.offset])) {
                return false;
            }
        } else if (header !== buffer[index + options.offset]) {
            return false;
        }
    }
    return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
    return new FileTypeParser(options).fromTokenizer(tokenizer);
}
async function fileTypeStream(webStream, options) {
    return new FileTypeParser(options).toDetectionStream(webStream, options);
}
class FileTypeParser {
    constructor(options){
        this.options = {
            mpegOffsetTolerance: 0,
            ...options
        };
        this.detectors = [
            ...options?.customDetectors ?? [],
            {
                id: 'core',
                detect: this.detectConfident
            },
            {
                id: 'core.imprecise',
                detect: this.detectImprecise
            }
        ];
        this.tokenizerOptions = {
            abortSignal: options?.signal
        };
    }
    async fromTokenizer(tokenizer) {
        const initialPosition = tokenizer.position;
        // Iterate through all file-type detectors
        for (const detector of this.detectors){
            const fileType = await detector.detect(tokenizer);
            if (fileType) {
                return fileType;
            }
            if (initialPosition !== tokenizer.position) {
                return undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position
            }
        }
    }
    async fromBuffer(input) {
        if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
        }
        const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
        if (!(buffer?.length > 1)) {
            return;
        }
        return this.fromTokenizer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBuffer"](buffer, this.tokenizerOptions));
    }
    async fromBlob(blob) {
        const tokenizer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBlob"](blob, this.tokenizerOptions);
        try {
            return await this.fromTokenizer(tokenizer);
        } finally{
            await tokenizer.close();
        }
    }
    async fromStream(stream) {
        const tokenizer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromWebStream"](stream, this.tokenizerOptions);
        try {
            return await this.fromTokenizer(tokenizer);
        } finally{
            await tokenizer.close();
        }
    }
    async toDetectionStream(stream, options) {
        const { sampleSize = reasonableDetectionSizeInBytes } = options;
        let detectedFileType;
        let firstChunk;
        const reader = stream.getReader({
            mode: 'byob'
        });
        try {
            // Read the first chunk from the stream
            const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
            firstChunk = chunk;
            if (!done && chunk) {
                try {
                    // Attempt to detect the file type from the chunk
                    detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
                } catch (error) {
                    if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"])) {
                        throw error; // Re-throw non-EndOfStreamError
                    }
                    detectedFileType = undefined;
                }
            }
            firstChunk = chunk;
        } finally{
            reader.releaseLock(); // Ensure the reader is released
        }
        // Create a new ReadableStream to manage locking issues
        const transformStream = new TransformStream({
            async start (controller) {
                controller.enqueue(firstChunk); // Enqueue the initial chunk
            },
            transform (chunk, controller) {
                // Pass through the chunks without modification
                controller.enqueue(chunk);
            }
        });
        const newStream = stream.pipeThrough(transformStream);
        newStream.fileType = detectedFileType;
        return newStream;
    }
    check(header, options) {
        return _check(this.buffer, header, options);
    }
    checkString(header, options) {
        return this.check((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stringToBytes"])(header, options?.encoding), options);
    }
    // Detections with a high degree of certainty in identifying the correct file type
    detectConfident = async (tokenizer)=>{
        this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
        // Keep reading until EOF if the file size is unknown.
        if (tokenizer.fileInfo.size === undefined) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
        }
        this.tokenizer = tokenizer;
        await tokenizer.peekBuffer(this.buffer, {
            length: 32,
            mayBeLess: true
        });
        // -- 2-byte signatures --
        if (this.check([
            0x42,
            0x4D
        ])) {
            return {
                ext: 'bmp',
                mime: 'image/bmp'
            };
        }
        if (this.check([
            0x0B,
            0x77
        ])) {
            return {
                ext: 'ac3',
                mime: 'audio/vnd.dolby.dd-raw'
            };
        }
        if (this.check([
            0x78,
            0x01
        ])) {
            return {
                ext: 'dmg',
                mime: 'application/x-apple-diskimage'
            };
        }
        if (this.check([
            0x4D,
            0x5A
        ])) {
            return {
                ext: 'exe',
                mime: 'application/x-msdownload'
            };
        }
        if (this.check([
            0x25,
            0x21
        ])) {
            await tokenizer.peekBuffer(this.buffer, {
                length: 24,
                mayBeLess: true
            });
            if (this.checkString('PS-Adobe-', {
                offset: 2
            }) && this.checkString(' EPSF-', {
                offset: 14
            })) {
                return {
                    ext: 'eps',
                    mime: 'application/eps'
                };
            }
            return {
                ext: 'ps',
                mime: 'application/postscript'
            };
        }
        if (this.check([
            0x1F,
            0xA0
        ]) || this.check([
            0x1F,
            0x9D
        ])) {
            return {
                ext: 'Z',
                mime: 'application/x-compress'
            };
        }
        if (this.check([
            0xC7,
            0x71
        ])) {
            return {
                ext: 'cpio',
                mime: 'application/x-cpio'
            };
        }
        if (this.check([
            0x60,
            0xEA
        ])) {
            return {
                ext: 'arj',
                mime: 'application/x-arj'
            };
        }
        // -- 3-byte signatures --
        if (this.check([
            0xEF,
            0xBB,
            0xBF
        ])) {
            // Strip off UTF-8-BOM
            this.tokenizer.ignore(3);
            return this.detectConfident(tokenizer);
        }
        if (this.check([
            0x47,
            0x49,
            0x46
        ])) {
            return {
                ext: 'gif',
                mime: 'image/gif'
            };
        }
        if (this.check([
            0x49,
            0x49,
            0xBC
        ])) {
            return {
                ext: 'jxr',
                mime: 'image/vnd.ms-photo'
            };
        }
        if (this.check([
            0x1F,
            0x8B,
            0x8
        ])) {
            const gzipHandler = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$GzipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GzipHandler"](tokenizer);
            const stream = gzipHandler.inflate();
            try {
                const compressedFileType = await this.fromStream(stream);
                if (compressedFileType && compressedFileType.ext === 'tar') {
                    return {
                        ext: 'tar.gz',
                        mime: 'application/gzip'
                    };
                }
            } finally{
                await stream.cancel();
            }
            return {
                ext: 'gz',
                mime: 'application/gzip'
            };
        }
        if (this.check([
            0x42,
            0x5A,
            0x68
        ])) {
            return {
                ext: 'bz2',
                mime: 'application/x-bzip2'
            };
        }
        if (this.checkString('ID3')) {
            await tokenizer.ignore(6); // Skip ID3 header until the header size
            const id3HeaderLength = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["uint32SyncSafeToken"]);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
                // Guess file type based on ID3 header for backward compatibility
                return {
                    ext: 'mp3',
                    mime: 'audio/mpeg'
                };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer); // Skip ID3 header, recursion
        }
        // Musepack, SV7
        if (this.checkString('MP+')) {
            return {
                ext: 'mpc',
                mime: 'audio/x-musepack'
            };
        }
        if ((this.buffer[0] === 0x43 || this.buffer[0] === 0x46) && this.check([
            0x57,
            0x53
        ], {
            offset: 1
        })) {
            return {
                ext: 'swf',
                mime: 'application/x-shockwave-flash'
            };
        }
        // -- 4-byte signatures --
        // Requires a sample size of 4 bytes
        if (this.check([
            0xFF,
            0xD8,
            0xFF
        ])) {
            if (this.check([
                0xF7
            ], {
                offset: 3
            })) {
                return {
                    ext: 'jls',
                    mime: 'image/jls'
                };
            }
            return {
                ext: 'jpg',
                mime: 'image/jpeg'
            };
        }
        if (this.check([
            0x4F,
            0x62,
            0x6A,
            0x01
        ])) {
            return {
                ext: 'avro',
                mime: 'application/avro'
            };
        }
        if (this.checkString('FLIF')) {
            return {
                ext: 'flif',
                mime: 'image/flif'
            };
        }
        if (this.checkString('8BPS')) {
            return {
                ext: 'psd',
                mime: 'image/vnd.adobe.photoshop'
            };
        }
        // Musepack, SV8
        if (this.checkString('MPCK')) {
            return {
                ext: 'mpc',
                mime: 'audio/x-musepack'
            };
        }
        if (this.checkString('FORM')) {
            return {
                ext: 'aif',
                mime: 'audio/aiff'
            };
        }
        if (this.checkString('icns', {
            offset: 0
        })) {
            return {
                ext: 'icns',
                mime: 'image/icns'
            };
        }
        // Zip-based file formats
        // Need to be before the `zip` check
        if (this.check([
            0x50,
            0x4B,
            0x3,
            0x4
        ])) {
            let fileType;
            await new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tokenizer$2b$inflate$40$0$2e$3$2e$1$2f$node_modules$2f40$tokenizer$2f$inflate$2f$lib$2f$ZipHandler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ZipHandler"](tokenizer).unzip((zipHeader)=>{
                switch(zipHeader.filename){
                    case 'META-INF/mozilla.rsa':
                        fileType = {
                            ext: 'xpi',
                            mime: 'application/x-xpinstall'
                        };
                        return {
                            stop: true
                        };
                    case 'META-INF/MANIFEST.MF':
                        fileType = {
                            ext: 'jar',
                            mime: 'application/java-archive'
                        };
                        return {
                            stop: true
                        };
                    case 'mimetype':
                        return {
                            async handler (fileData) {
                                // Use TextDecoder to decode the UTF-8 encoded data
                                const mimeType = new TextDecoder('utf-8').decode(fileData).trim();
                                fileType = getFileTypeFromMimeType(mimeType);
                            },
                            stop: true
                        };
                    case '[Content_Types].xml':
                        return {
                            async handler (fileData) {
                                // Use TextDecoder to decode the UTF-8 encoded data
                                let xmlContent = new TextDecoder('utf-8').decode(fileData);
                                const endPos = xmlContent.indexOf('.main+xml"');
                                if (endPos === -1) {
                                    const mimeType = 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml';
                                    if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                                        fileType = getFileTypeFromMimeType(mimeType);
                                    }
                                } else {
                                    xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                                    const firstPos = xmlContent.lastIndexOf('"');
                                    const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                                    fileType = getFileTypeFromMimeType(mimeType);
                                }
                            },
                            stop: true
                        };
                    default:
                        if (/classes\d*\.dex/.test(zipHeader.filename)) {
                            fileType = {
                                ext: 'apk',
                                mime: 'application/vnd.android.package-archive'
                            };
                            return {
                                stop: true
                            };
                        }
                        return {};
                }
            }).catch((error)=>{
                if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$10$2e$3$2e$4$2f$node_modules$2f$strtok3$2f$lib$2f$stream$2f$Errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EndOfStreamError"])) {
                    throw error; // Re-throw non-EndOfStreamError
                }
            });
            return fileType ?? {
                ext: 'zip',
                mime: 'application/zip'
            };
        }
        if (this.checkString('OggS')) {
            // This is an OGG container
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            // Needs to be before `ogg` check
            if (_check(type, [
                0x4F,
                0x70,
                0x75,
                0x73,
                0x48,
                0x65,
                0x61,
                0x64
            ])) {
                return {
                    ext: 'opus',
                    mime: 'audio/ogg; codecs=opus'
                };
            }
            // If ' theora' in header.
            if (_check(type, [
                0x80,
                0x74,
                0x68,
                0x65,
                0x6F,
                0x72,
                0x61
            ])) {
                return {
                    ext: 'ogv',
                    mime: 'video/ogg'
                };
            }
            // If '\x01video' in header.
            if (_check(type, [
                0x01,
                0x76,
                0x69,
                0x64,
                0x65,
                0x6F,
                0x00
            ])) {
                return {
                    ext: 'ogm',
                    mime: 'video/ogg'
                };
            }
            // If ' FLAC' in header  https://xiph.org/flac/faq.html
            if (_check(type, [
                0x7F,
                0x46,
                0x4C,
                0x41,
                0x43
            ])) {
                return {
                    ext: 'oga',
                    mime: 'audio/ogg'
                };
            }
            // 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
            if (_check(type, [
                0x53,
                0x70,
                0x65,
                0x65,
                0x78,
                0x20,
                0x20
            ])) {
                return {
                    ext: 'spx',
                    mime: 'audio/ogg'
                };
            }
            // If '\x01vorbis' in header
            if (_check(type, [
                0x01,
                0x76,
                0x6F,
                0x72,
                0x62,
                0x69,
                0x73
            ])) {
                return {
                    ext: 'ogg',
                    mime: 'audio/ogg'
                };
            }
            // Default OGG container https://www.iana.org/assignments/media-types/application/ogg
            return {
                ext: 'ogx',
                mime: 'application/ogg'
            };
        }
        if (this.check([
            0x50,
            0x4B
        ]) && (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7) && (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)) {
            return {
                ext: 'zip',
                mime: 'application/zip'
            };
        }
        if (this.checkString('MThd')) {
            return {
                ext: 'mid',
                mime: 'audio/midi'
            };
        }
        if (this.checkString('wOFF') && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString('OTTO', {
            offset: 4
        }))) {
            return {
                ext: 'woff',
                mime: 'font/woff'
            };
        }
        if (this.checkString('wOF2') && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString('OTTO', {
            offset: 4
        }))) {
            return {
                ext: 'woff2',
                mime: 'font/woff2'
            };
        }
        if (this.check([
            0xD4,
            0xC3,
            0xB2,
            0xA1
        ]) || this.check([
            0xA1,
            0xB2,
            0xC3,
            0xD4
        ])) {
            return {
                ext: 'pcap',
                mime: 'application/vnd.tcpdump.pcap'
            };
        }
        // Sony DSD Stream File (DSF)
        if (this.checkString('DSD ')) {
            return {
                ext: 'dsf',
                mime: 'audio/x-dsf'
            };
        }
        if (this.checkString('LZIP')) {
            return {
                ext: 'lz',
                mime: 'application/x-lzip'
            };
        }
        if (this.checkString('fLaC')) {
            return {
                ext: 'flac',
                mime: 'audio/flac'
            };
        }
        if (this.check([
            0x42,
            0x50,
            0x47,
            0xFB
        ])) {
            return {
                ext: 'bpg',
                mime: 'image/bpg'
            };
        }
        if (this.checkString('wvpk')) {
            return {
                ext: 'wv',
                mime: 'audio/wavpack'
            };
        }
        if (this.checkString('%PDF')) {
            // Assume this is just a normal PDF
            return {
                ext: 'pdf',
                mime: 'application/pdf'
            };
        }
        if (this.check([
            0x00,
            0x61,
            0x73,
            0x6D
        ])) {
            return {
                ext: 'wasm',
                mime: 'application/wasm'
            };
        }
        // TIFF, little-endian type
        if (this.check([
            0x49,
            0x49
        ])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
                return fileType;
            }
        }
        // TIFF, big-endian type
        if (this.check([
            0x4D,
            0x4D
        ])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
                return fileType;
            }
        }
        if (this.checkString('MAC ')) {
            return {
                ext: 'ape',
                mime: 'audio/ape'
            };
        }
        // https://github.com/file/file/blob/master/magic/Magdir/matroska
        if (this.check([
            0x1A,
            0x45,
            0xDF,
            0xA3
        ])) {
            async function readField() {
                const msb = await tokenizer.peekNumber(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT8"]);
                let mask = 0x80;
                let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D
                while((msb & mask) === 0 && mask !== 0){
                    ++ic;
                    mask >>= 1;
                }
                const id = new Uint8Array(ic + 1);
                await tokenizer.readBuffer(id);
                return id;
            }
            async function readElement() {
                const idField = await readField();
                const lengthField = await readField();
                lengthField[0] ^= 0x80 >> lengthField.length - 1;
                const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer
                const idView = new DataView(idField.buffer);
                const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
                return {
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUintBE"])(idView),
                    len: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUintBE"])(lengthView)
                };
            }
            async function readChildren(children) {
                while(children > 0){
                    const element = await readElement();
                    if (element.id === 0x42_82) {
                        const rawValue = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](element.len));
                        return rawValue.replaceAll(/\00.*$/g, ''); // Return DocType
                    }
                    await tokenizer.ignore(element.len); // ignore payload
                    --children;
                }
            }
            const re = await readElement();
            const documentType = await readChildren(re.len);
            switch(documentType){
                case 'webm':
                    return {
                        ext: 'webm',
                        mime: 'video/webm'
                    };
                case 'matroska':
                    return {
                        ext: 'mkv',
                        mime: 'video/matroska'
                    };
                default:
                    return;
            }
        }
        if (this.checkString('SQLi')) {
            return {
                ext: 'sqlite',
                mime: 'application/x-sqlite3'
            };
        }
        if (this.check([
            0x4E,
            0x45,
            0x53,
            0x1A
        ])) {
            return {
                ext: 'nes',
                mime: 'application/x-nintendo-nes-rom'
            };
        }
        if (this.checkString('Cr24')) {
            return {
                ext: 'crx',
                mime: 'application/x-google-chrome-extension'
            };
        }
        if (this.checkString('MSCF') || this.checkString('ISc(')) {
            return {
                ext: 'cab',
                mime: 'application/vnd.ms-cab-compressed'
            };
        }
        if (this.check([
            0xED,
            0xAB,
            0xEE,
            0xDB
        ])) {
            return {
                ext: 'rpm',
                mime: 'application/x-rpm'
            };
        }
        if (this.check([
            0xC5,
            0xD0,
            0xD3,
            0xC6
        ])) {
            return {
                ext: 'eps',
                mime: 'application/eps'
            };
        }
        if (this.check([
            0x28,
            0xB5,
            0x2F,
            0xFD
        ])) {
            return {
                ext: 'zst',
                mime: 'application/zstd'
            };
        }
        if (this.check([
            0x7F,
            0x45,
            0x4C,
            0x46
        ])) {
            return {
                ext: 'elf',
                mime: 'application/x-elf'
            };
        }
        if (this.check([
            0x21,
            0x42,
            0x44,
            0x4E
        ])) {
            return {
                ext: 'pst',
                mime: 'application/vnd.ms-outlook'
            };
        }
        if (this.checkString('PAR1') || this.checkString('PARE')) {
            return {
                ext: 'parquet',
                mime: 'application/vnd.apache.parquet'
            };
        }
        if (this.checkString('ttcf')) {
            return {
                ext: 'ttc',
                mime: 'font/collection'
            };
        }
        if (this.check([
            0xCF,
            0xFA,
            0xED,
            0xFE
        ])) {
            return {
                ext: 'macho',
                mime: 'application/x-mach-binary'
            };
        }
        if (this.check([
            0x04,
            0x22,
            0x4D,
            0x18
        ])) {
            return {
                ext: 'lz4',
                mime: 'application/x-lz4'
            };
        }
        if (this.checkString('regf')) {
            return {
                ext: 'dat',
                mime: 'application/x-ft-windows-registry-hive'
            };
        }
        // -- 5-byte signatures --
        if (this.check([
            0x4F,
            0x54,
            0x54,
            0x4F,
            0x00
        ])) {
            return {
                ext: 'otf',
                mime: 'font/otf'
            };
        }
        if (this.checkString('#!AMR')) {
            return {
                ext: 'amr',
                mime: 'audio/amr'
            };
        }
        if (this.checkString('{\\rtf')) {
            return {
                ext: 'rtf',
                mime: 'application/rtf'
            };
        }
        if (this.check([
            0x46,
            0x4C,
            0x56,
            0x01
        ])) {
            return {
                ext: 'flv',
                mime: 'video/x-flv'
            };
        }
        if (this.checkString('IMPM')) {
            return {
                ext: 'it',
                mime: 'audio/x-it'
            };
        }
        if (this.checkString('-lh0-', {
            offset: 2
        }) || this.checkString('-lh1-', {
            offset: 2
        }) || this.checkString('-lh2-', {
            offset: 2
        }) || this.checkString('-lh3-', {
            offset: 2
        }) || this.checkString('-lh4-', {
            offset: 2
        }) || this.checkString('-lh5-', {
            offset: 2
        }) || this.checkString('-lh6-', {
            offset: 2
        }) || this.checkString('-lh7-', {
            offset: 2
        }) || this.checkString('-lzs-', {
            offset: 2
        }) || this.checkString('-lz4-', {
            offset: 2
        }) || this.checkString('-lz5-', {
            offset: 2
        }) || this.checkString('-lhd-', {
            offset: 2
        })) {
            return {
                ext: 'lzh',
                mime: 'application/x-lzh-compressed'
            };
        }
        // MPEG program stream (PS or MPEG-PS)
        if (this.check([
            0x00,
            0x00,
            0x01,
            0xBA
        ])) {
            //  MPEG-PS, MPEG-1 Part 1
            if (this.check([
                0x21
            ], {
                offset: 4,
                mask: [
                    0xF1
                ]
            })) {
                return {
                    ext: 'mpg',
                    mime: 'video/MP1S'
                };
            }
            // MPEG-PS, MPEG-2 Part 1
            if (this.check([
                0x44
            ], {
                offset: 4,
                mask: [
                    0xC4
                ]
            })) {
                return {
                    ext: 'mpg',
                    mime: 'video/MP2P'
                };
            }
        }
        if (this.checkString('ITSF')) {
            return {
                ext: 'chm',
                mime: 'application/vnd.ms-htmlhelp'
            };
        }
        if (this.check([
            0xCA,
            0xFE,
            0xBA,
            0xBE
        ])) {
            return {
                ext: 'class',
                mime: 'application/java-vm'
            };
        }
        if (this.checkString('.RMF')) {
            return {
                ext: 'rm',
                mime: 'application/vnd.rn-realmedia'
            };
        }
        // -- 5-byte signatures --
        if (this.checkString('DRACO')) {
            return {
                ext: 'drc',
                mime: 'application/vnd.google.draco'
            };
        }
        // -- 6-byte signatures --
        if (this.check([
            0xFD,
            0x37,
            0x7A,
            0x58,
            0x5A,
            0x00
        ])) {
            return {
                ext: 'xz',
                mime: 'application/x-xz'
            };
        }
        if (this.checkString('<?xml ')) {
            return {
                ext: 'xml',
                mime: 'application/xml'
            };
        }
        if (this.check([
            0x37,
            0x7A,
            0xBC,
            0xAF,
            0x27,
            0x1C
        ])) {
            return {
                ext: '7z',
                mime: 'application/x-7z-compressed'
            };
        }
        if (this.check([
            0x52,
            0x61,
            0x72,
            0x21,
            0x1A,
            0x7
        ]) && (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)) {
            return {
                ext: 'rar',
                mime: 'application/x-rar-compressed'
            };
        }
        if (this.checkString('solid ')) {
            return {
                ext: 'stl',
                mime: 'model/stl'
            };
        }
        if (this.checkString('AC')) {
            const version = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1').get(this.buffer, 2);
            if (version.match('^d*') && version >= 1000 && version <= 1050) {
                return {
                    ext: 'dwg',
                    mime: 'image/vnd.dwg'
                };
            }
        }
        if (this.checkString('070707')) {
            return {
                ext: 'cpio',
                mime: 'application/x-cpio'
            };
        }
        // -- 7-byte signatures --
        if (this.checkString('BLENDER')) {
            return {
                ext: 'blend',
                mime: 'application/x-blender'
            };
        }
        if (this.checkString('!<arch>')) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](13, 'ascii'));
            if (string === 'debian-binary') {
                return {
                    ext: 'deb',
                    mime: 'application/x-deb'
                };
            }
            return {
                ext: 'ar',
                mime: 'application/x-unix-archive'
            };
        }
        if (this.checkString('WEBVTT') && [
            '\n',
            '\r',
            '\t',
            ' ',
            '\0'
        ].some((char7)=>this.checkString(char7, {
                offset: 6
            }))) {
            return {
                ext: 'vtt',
                mime: 'text/vtt'
            };
        }
        // -- 8-byte signatures --
        if (this.check([
            0x89,
            0x50,
            0x4E,
            0x47,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) {
            // APNG format (https://wiki.mozilla.org/APNG_Specification)
            // 1. Find the first IDAT (image data) chunk (49 44 41 54)
            // 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)
            // Offset calculated as follows:
            // - 8 bytes: PNG signature
            // - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk
            await tokenizer.ignore(8); // ignore PNG signature
            async function readChunkHeader() {
                return {
                    length: await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["INT32_BE"]),
                    type: await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1'))
                };
            }
            do {
                const chunk = await readChunkHeader();
                if (chunk.length < 0) {
                    return; // Invalid chunk length
                }
                switch(chunk.type){
                    case 'IDAT':
                        return {
                            ext: 'png',
                            mime: 'image/png'
                        };
                    case 'acTL':
                        return {
                            ext: 'apng',
                            mime: 'image/apng'
                        };
                    default:
                        await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
                }
            }while (tokenizer.position + 8 < tokenizer.fileInfo.size)
            return {
                ext: 'png',
                mime: 'image/png'
            };
        }
        if (this.check([
            0x41,
            0x52,
            0x52,
            0x4F,
            0x57,
            0x31,
            0x00,
            0x00
        ])) {
            return {
                ext: 'arrow',
                mime: 'application/vnd.apache.arrow.file'
            };
        }
        if (this.check([
            0x67,
            0x6C,
            0x54,
            0x46,
            0x02,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'glb',
                mime: 'model/gltf-binary'
            };
        }
        // `mov` format variants
        if (this.check([
            0x66,
            0x72,
            0x65,
            0x65
        ], {
            offset: 4
        }) // `free`
         || this.check([
            0x6D,
            0x64,
            0x61,
            0x74
        ], {
            offset: 4
        }) // `mdat` MJPEG
         || this.check([
            0x6D,
            0x6F,
            0x6F,
            0x76
        ], {
            offset: 4
        }) // `moov`
         || this.check([
            0x77,
            0x69,
            0x64,
            0x65
        ], {
            offset: 4
        }) // `wide`
        ) {
            return {
                ext: 'mov',
                mime: 'video/quicktime'
            };
        }
        // -- 9-byte signatures --
        if (this.check([
            0x49,
            0x49,
            0x52,
            0x4F,
            0x08,
            0x00,
            0x00,
            0x00,
            0x18
        ])) {
            return {
                ext: 'orf',
                mime: 'image/x-olympus-orf'
            };
        }
        if (this.checkString('gimp xcf ')) {
            return {
                ext: 'xcf',
                mime: 'image/x-xcf'
            };
        }
        // File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
        // It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
        // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
        // Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
        if (this.checkString('ftyp', {
            offset: 4
        }) && (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
        ) {
            // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
            // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
            const brandMajor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1').get(this.buffer, 8).replace('\0', ' ').trim();
            switch(brandMajor){
                case 'avif':
                case 'avis':
                    return {
                        ext: 'avif',
                        mime: 'image/avif'
                    };
                case 'mif1':
                    return {
                        ext: 'heic',
                        mime: 'image/heif'
                    };
                case 'msf1':
                    return {
                        ext: 'heic',
                        mime: 'image/heif-sequence'
                    };
                case 'heic':
                case 'heix':
                    return {
                        ext: 'heic',
                        mime: 'image/heic'
                    };
                case 'hevc':
                case 'hevx':
                    return {
                        ext: 'heic',
                        mime: 'image/heic-sequence'
                    };
                case 'qt':
                    return {
                        ext: 'mov',
                        mime: 'video/quicktime'
                    };
                case 'M4V':
                case 'M4VH':
                case 'M4VP':
                    return {
                        ext: 'm4v',
                        mime: 'video/x-m4v'
                    };
                case 'M4P':
                    return {
                        ext: 'm4p',
                        mime: 'video/mp4'
                    };
                case 'M4B':
                    return {
                        ext: 'm4b',
                        mime: 'audio/mp4'
                    };
                case 'M4A':
                    return {
                        ext: 'm4a',
                        mime: 'audio/x-m4a'
                    };
                case 'F4V':
                    return {
                        ext: 'f4v',
                        mime: 'video/mp4'
                    };
                case 'F4P':
                    return {
                        ext: 'f4p',
                        mime: 'video/mp4'
                    };
                case 'F4A':
                    return {
                        ext: 'f4a',
                        mime: 'audio/mp4'
                    };
                case 'F4B':
                    return {
                        ext: 'f4b',
                        mime: 'audio/mp4'
                    };
                case 'crx':
                    return {
                        ext: 'cr3',
                        mime: 'image/x-canon-cr3'
                    };
                default:
                    if (brandMajor.startsWith('3g')) {
                        if (brandMajor.startsWith('3g2')) {
                            return {
                                ext: '3g2',
                                mime: 'video/3gpp2'
                            };
                        }
                        return {
                            ext: '3gp',
                            mime: 'video/3gpp'
                        };
                    }
                    return {
                        ext: 'mp4',
                        mime: 'video/mp4'
                    };
            }
        }
        // -- 10-byte signatures --
        if (this.checkString('REGEDIT4\r\n')) {
            return {
                ext: 'reg',
                mime: 'application/x-ms-regedit'
            };
        }
        // -- 12-byte signatures --
        // RIFF file format which might be AVI, WAV, QCP, etc
        if (this.check([
            0x52,
            0x49,
            0x46,
            0x46
        ])) {
            if (this.checkString('WEBP', {
                offset: 8
            })) {
                return {
                    ext: 'webp',
                    mime: 'image/webp'
                };
            }
            if (this.check([
                0x41,
                0x56,
                0x49
            ], {
                offset: 8
            })) {
                return {
                    ext: 'avi',
                    mime: 'video/vnd.avi'
                };
            }
            if (this.check([
                0x57,
                0x41,
                0x56,
                0x45
            ], {
                offset: 8
            })) {
                return {
                    ext: 'wav',
                    mime: 'audio/wav'
                };
            }
            // QLCM, QCP file
            if (this.check([
                0x51,
                0x4C,
                0x43,
                0x4D
            ], {
                offset: 8
            })) {
                return {
                    ext: 'qcp',
                    mime: 'audio/qcelp'
                };
            }
        }
        if (this.check([
            0x49,
            0x49,
            0x55,
            0x00,
            0x18,
            0x00,
            0x00,
            0x00,
            0x88,
            0xE7,
            0x74,
            0xD8
        ])) {
            return {
                ext: 'rw2',
                mime: 'image/x-panasonic-rw2'
            };
        }
        // ASF_Header_Object first 80 bytes
        if (this.check([
            0x30,
            0x26,
            0xB2,
            0x75,
            0x8E,
            0x66,
            0xCF,
            0x11,
            0xA6,
            0xD9
        ])) {
            async function readHeader() {
                const guid = new Uint8Array(16);
                await tokenizer.readBuffer(guid);
                return {
                    id: guid,
                    size: Number(await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT64_LE"]))
                };
            }
            await tokenizer.ignore(30);
            // Search for header should be in first 1KB of file.
            while(tokenizer.position + 24 < tokenizer.fileInfo.size){
                const header = await readHeader();
                let payload = header.size - 24;
                if (_check(header.id, [
                    0x91,
                    0x07,
                    0xDC,
                    0xB7,
                    0xB7,
                    0xA9,
                    0xCF,
                    0x11,
                    0x8E,
                    0xE6,
                    0x00,
                    0xC0,
                    0x0C,
                    0x20,
                    0x53,
                    0x65
                ])) {
                    // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
                    const typeId = new Uint8Array(16);
                    payload -= await tokenizer.readBuffer(typeId);
                    if (_check(typeId, [
                        0x40,
                        0x9E,
                        0x69,
                        0xF8,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) {
                        // Found audio:
                        return {
                            ext: 'asf',
                            mime: 'audio/x-ms-asf'
                        };
                    }
                    if (_check(typeId, [
                        0xC0,
                        0xEF,
                        0x19,
                        0xBC,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) {
                        // Found video:
                        return {
                            ext: 'asf',
                            mime: 'video/x-ms-asf'
                        };
                    }
                    break;
                }
                await tokenizer.ignore(payload);
            }
            // Default to ASF generic extension
            return {
                ext: 'asf',
                mime: 'application/vnd.ms-asf'
            };
        }
        if (this.check([
            0xAB,
            0x4B,
            0x54,
            0x58,
            0x20,
            0x31,
            0x31,
            0xBB,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) {
            return {
                ext: 'ktx',
                mime: 'image/ktx'
            };
        }
        if ((this.check([
            0x7E,
            0x10,
            0x04
        ]) || this.check([
            0x7E,
            0x18,
            0x04
        ])) && this.check([
            0x30,
            0x4D,
            0x49,
            0x45
        ], {
            offset: 4
        })) {
            return {
                ext: 'mie',
                mime: 'application/x-mie'
            };
        }
        if (this.check([
            0x27,
            0x0A,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00
        ], {
            offset: 2
        })) {
            return {
                ext: 'shp',
                mime: 'application/x-esri-shape'
            };
        }
        if (this.check([
            0xFF,
            0x4F,
            0xFF,
            0x51
        ])) {
            return {
                ext: 'j2c',
                mime: 'image/j2c'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x6A,
            0x50,
            0x20,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) {
            // JPEG-2000 family
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["StringType"](4, 'ascii'));
            switch(type){
                case 'jp2 ':
                    return {
                        ext: 'jp2',
                        mime: 'image/jp2'
                    };
                case 'jpx ':
                    return {
                        ext: 'jpx',
                        mime: 'image/jpx'
                    };
                case 'jpm ':
                    return {
                        ext: 'jpm',
                        mime: 'image/jpm'
                    };
                case 'mjp2':
                    return {
                        ext: 'mj2',
                        mime: 'image/mj2'
                    };
                default:
                    return;
            }
        }
        if (this.check([
            0xFF,
            0x0A
        ]) || this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x4A,
            0x58,
            0x4C,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) {
            return {
                ext: 'jxl',
                mime: 'image/jxl'
            };
        }
        if (this.check([
            0xFE,
            0xFF
        ])) {
            if (this.checkString('<?xml ', {
                offset: 2,
                encoding: 'utf-16be'
            })) {
                return {
                    ext: 'xml',
                    mime: 'application/xml'
                };
            }
            return undefined; // Some unknown text based format
        }
        if (this.check([
            0xD0,
            0xCF,
            0x11,
            0xE0,
            0xA1,
            0xB1,
            0x1A,
            0xE1
        ])) {
            // Detected Microsoft Compound File Binary File (MS-CFB) Format.
            return {
                ext: 'cfb',
                mime: 'application/x-cfb'
            };
        }
        // Increase sample size from 32 to 256.
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(256, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        if (this.check([
            0x61,
            0x63,
            0x73,
            0x70
        ], {
            offset: 36
        })) {
            return {
                ext: 'icc',
                mime: 'application/vnd.iccprofile'
            };
        }
        // ACE: requires 14 bytes in the buffer
        if (this.checkString('**ACE', {
            offset: 7
        }) && this.checkString('**', {
            offset: 12
        })) {
            return {
                ext: 'ace',
                mime: 'application/x-ace-compressed'
            };
        }
        // -- 15-byte signatures --
        if (this.checkString('BEGIN:')) {
            if (this.checkString('VCARD', {
                offset: 6
            })) {
                return {
                    ext: 'vcf',
                    mime: 'text/vcard'
                };
            }
            if (this.checkString('VCALENDAR', {
                offset: 6
            })) {
                return {
                    ext: 'ics',
                    mime: 'text/calendar'
                };
            }
        }
        // `raf` is here just to keep all the raw image detectors together.
        if (this.checkString('FUJIFILMCCD-RAW')) {
            return {
                ext: 'raf',
                mime: 'image/x-fujifilm-raf'
            };
        }
        if (this.checkString('Extended Module:')) {
            return {
                ext: 'xm',
                mime: 'audio/x-xm'
            };
        }
        if (this.checkString('Creative Voice File')) {
            return {
                ext: 'voc',
                mime: 'audio/x-voc'
            };
        }
        if (this.check([
            0x04,
            0x00,
            0x00,
            0x00
        ]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
                try {
                    const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
                    const json = JSON.parse(header);
                    // Check if Pickle is ASAR
                    if (json.files) {
                        return {
                            ext: 'asar',
                            mime: 'application/x-asar'
                        };
                    }
                } catch  {}
            }
        }
        if (this.check([
            0x06,
            0x0E,
            0x2B,
            0x34,
            0x02,
            0x05,
            0x01,
            0x01,
            0x0D,
            0x01,
            0x02,
            0x01,
            0x01,
            0x02
        ])) {
            return {
                ext: 'mxf',
                mime: 'application/mxf'
            };
        }
        if (this.checkString('SCRM', {
            offset: 44
        })) {
            return {
                ext: 's3m',
                mime: 'audio/x-s3m'
            };
        }
        // Raw MPEG-2 transport stream (188-byte packets)
        if (this.check([
            0x47
        ]) && this.check([
            0x47
        ], {
            offset: 188
        })) {
            return {
                ext: 'mts',
                mime: 'video/mp2t'
            };
        }
        // Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
        if (this.check([
            0x47
        ], {
            offset: 4
        }) && this.check([
            0x47
        ], {
            offset: 196
        })) {
            return {
                ext: 'mts',
                mime: 'video/mp2t'
            };
        }
        if (this.check([
            0x42,
            0x4F,
            0x4F,
            0x4B,
            0x4D,
            0x4F,
            0x42,
            0x49
        ], {
            offset: 60
        })) {
            return {
                ext: 'mobi',
                mime: 'application/x-mobipocket-ebook'
            };
        }
        if (this.check([
            0x44,
            0x49,
            0x43,
            0x4D
        ], {
            offset: 128
        })) {
            return {
                ext: 'dcm',
                mime: 'application/dicom'
            };
        }
        if (this.check([
            0x4C,
            0x00,
            0x00,
            0x00,
            0x01,
            0x14,
            0x02,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xC0,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x46
        ])) {
            return {
                ext: 'lnk',
                mime: 'application/x.ms.shortcut'
            };
        }
        if (this.check([
            0x62,
            0x6F,
            0x6F,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00,
            0x6D,
            0x61,
            0x72,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'alias',
                mime: 'application/x.apple.alias'
            };
        }
        if (this.checkString('Kaydara FBX Binary  \u0000')) {
            return {
                ext: 'fbx',
                mime: 'application/x.autodesk.fbx'
            };
        }
        if (this.check([
            0x4C,
            0x50
        ], {
            offset: 34
        }) && (this.check([
            0x00,
            0x00,
            0x01
        ], {
            offset: 8
        }) || this.check([
            0x01,
            0x00,
            0x02
        ], {
            offset: 8
        }) || this.check([
            0x02,
            0x00,
            0x02
        ], {
            offset: 8
        }))) {
            return {
                ext: 'eot',
                mime: 'application/vnd.ms-fontobject'
            };
        }
        if (this.check([
            0x06,
            0x06,
            0xED,
            0xF5,
            0xD8,
            0x1D,
            0x46,
            0xE5,
            0xBD,
            0x31,
            0xEF,
            0xE7,
            0xFE,
            0x74,
            0xB7,
            0x1D
        ])) {
            return {
                ext: 'indd',
                mime: 'application/x-indesign'
            };
        }
        // Increase sample size from 256 to 512
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(512, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        // Requires a buffer size of 512 bytes
        if (this.checkString('ustar', {
            offset: 257
        }) && (this.checkString('\0', {
            offset: 262
        }) || this.checkString(' ', {
            offset: 262
        })) || this.check([
            0,
            0,
            0,
            0,
            0,
            0
        ], {
            offset: 257
        }) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tarHeaderChecksumMatches"])(this.buffer)) {
            return {
                ext: 'tar',
                mime: 'application/x-tar'
            };
        }
        if (this.check([
            0xFF,
            0xFE
        ])) {
            const encoding = 'utf-16le';
            if (this.checkString('<?xml ', {
                offset: 2,
                encoding
            })) {
                return {
                    ext: 'xml',
                    mime: 'application/xml'
                };
            }
            if (this.check([
                0xFF,
                0x0E
            ], {
                offset: 2
            }) && this.checkString('SketchUp Model', {
                offset: 4,
                encoding
            })) {
                return {
                    ext: 'skp',
                    mime: 'application/vnd.sketchup.skp'
                };
            }
            if (this.checkString('Windows Registry Editor Version 5.00\r\n', {
                offset: 2,
                encoding
            })) {
                return {
                    ext: 'reg',
                    mime: 'application/x-ms-regedit'
                };
            }
            return undefined; // Some text based format
        }
        if (this.checkString('-----BEGIN PGP MESSAGE-----')) {
            return {
                ext: 'pgp',
                mime: 'application/pgp-encrypted'
            };
        }
    };
    // Detections with limited supporting data, resulting in a higher likelihood of false positives
    detectImprecise = async (tokenizer)=>{
        this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
        // Read initial sample size of 8 bytes
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(8, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        if (this.check([
            0x0,
            0x0,
            0x1,
            0xBA
        ]) || this.check([
            0x0,
            0x0,
            0x1,
            0xB3
        ])) {
            return {
                ext: 'mpg',
                mime: 'video/mpeg'
            };
        }
        if (this.check([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'ttf',
                mime: 'font/ttf'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x01,
            0x00
        ])) {
            return {
                ext: 'ico',
                mime: 'image/x-icon'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x02,
            0x00
        ])) {
            return {
                ext: 'cur',
                mime: 'image/x-icon'
            };
        }
        // Adjust buffer to `mpegOffsetTolerance`
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        // Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
        if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
            for(let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth){
                const type = this.scanMpeg(depth);
                if (type) {
                    return type;
                }
            }
        }
    };
    async readTiffTag(bigEndian) {
        const tagId = await this.tokenizer.readToken(bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"]);
        this.tokenizer.ignore(10);
        switch(tagId){
            case 50_341:
                return {
                    ext: 'arw',
                    mime: 'image/x-sony-arw'
                };
            case 50_706:
                return {
                    ext: 'dng',
                    mime: 'image/x-adobe-dng'
                };
            default:
        }
    }
    async readTiffIFD(bigEndian) {
        const numberOfTags = await this.tokenizer.readToken(bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"]);
        for(let n = 0; n < numberOfTags; ++n){
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
                return fileType;
            }
        }
    }
    async readTiffHeader(bigEndian) {
        const version = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"]).get(this.buffer, 2);
        const ifdOffset = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_LE"]).get(this.buffer, 4);
        if (version === 42) {
            // TIFF file header
            if (ifdOffset >= 6) {
                if (this.checkString('CR', {
                    offset: 8
                })) {
                    return {
                        ext: 'cr2',
                        mime: 'image/x-canon-cr2'
                    };
                }
                if (ifdOffset >= 8) {
                    const someId1 = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"]).get(this.buffer, 8);
                    const someId2 = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT16_LE"]).get(this.buffer, 10);
                    if (someId1 === 0x1C && someId2 === 0xFE || someId1 === 0x1F && someId2 === 0x0B) {
                        return {
                            ext: 'nef',
                            mime: 'image/x-nikon-nef'
                        };
                    }
                }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
                ext: 'tif',
                mime: 'image/tiff'
            };
        }
        if (version === 43) {
            return {
                ext: 'tif',
                mime: 'image/tiff'
            };
        }
    }
    /**
	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).

	@param offset - Offset to scan for sync-preamble.
	@returns {{ext: string, mime: string}}
	*/ scanMpeg(offset) {
        if (this.check([
            0xFF,
            0xE0
        ], {
            offset,
            mask: [
                0xFF,
                0xE0
            ]
        })) {
            if (this.check([
                0x10
            ], {
                offset: offset + 1,
                mask: [
                    0x16
                ]
            })) {
                // Check for (ADTS) MPEG-2
                if (this.check([
                    0x08
                ], {
                    offset: offset + 1,
                    mask: [
                        0x08
                    ]
                })) {
                    return {
                        ext: 'aac',
                        mime: 'audio/aac'
                    };
                }
                // Must be (ADTS) MPEG-4
                return {
                    ext: 'aac',
                    mime: 'audio/aac'
                };
            }
            // MPEG 1 or 2 Layer 3 header
            // Check for MPEG layer 3
            if (this.check([
                0x02
            ], {
                offset: offset + 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp3',
                    mime: 'audio/mpeg'
                };
            }
            // Check for MPEG layer 2
            if (this.check([
                0x04
            ], {
                offset: offset + 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp2',
                    mime: 'audio/mpeg'
                };
            }
            // Check for MPEG layer 1
            if (this.check([
                0x06
            ], {
                offset: offset + 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp1',
                    mime: 'audio/mpeg'
                };
            }
        }
    }
}
const supportedExtensions = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["extensions"]);
const supportedMimeTypes = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$21$2e$1$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mimeTypes"]);
}),
"[project]/node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
;
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
;
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */ var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex
;
/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */ var QUOTE_REGEXP = /([\\"])/g;
/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */ var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
/**
 * Module exports.
 * @public
 */ exports.format = format;
exports.parse = parse;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */ function format(obj) {
    if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required');
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    var string = type;
    // append parameters
    if (parameters && typeof parameters === 'object') {
        var param;
        var params = Object.keys(parameters).sort();
        for(var i = 0; i < params.length; i++){
            param = params[i];
            if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError('invalid parameter name');
            }
            string += '; ' + param + '=' + qstring(parameters[param]);
        }
    }
    return string;
}
/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */ function parse(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    // support req/res-like objects as argument
    var header = typeof string === 'object' ? getcontenttype(string) : string;
    if (typeof header !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    var index = header.indexOf(';');
    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
        throw new TypeError('invalid media type');
    }
    var obj = new ContentType(type.toLowerCase());
    // parse parameters
    if (index !== -1) {
        var key;
        var match;
        var value;
        PARAM_REGEXP.lastIndex = index;
        while(match = PARAM_REGEXP.exec(header)){
            if (match.index !== index) {
                throw new TypeError('invalid parameter format');
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];
            if (value.charCodeAt(0) === 0x22 /* " */ ) {
                // remove quotes
                value = value.slice(1, -1);
                // remove escapes
                if (value.indexOf('\\') !== -1) {
                    value = value.replace(QESC_REGEXP, '$1');
                }
            }
            obj.parameters[key] = value;
        }
        if (index !== header.length) {
            throw new TypeError('invalid parameter format');
        }
    }
    return obj;
}
/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */ function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === 'function') {
        // res-like
        header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
        // req-like
        header = obj.headers && obj.headers['content-type'];
    }
    if (typeof header !== 'string') {
        throw new TypeError('content-type header is missing from object');
    }
    return header;
}
/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */ function qstring(val) {
    var str = String(val);
    // no need to quote tokens
    if (TOKEN_REGEXP.test(str)) {
        return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
        throw new TypeError('invalid parameter value');
    }
    return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}
/**
 * Class to represent a content type.
 * @private
 */ function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
}
}),
"[project]/node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/mimeScore.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// 'mime-score' back-ported to CommonJS
// Score RFC facets (see https://tools.ietf.org/html/rfc6838#section-3)
var FACET_SCORES = {
    'prs.': 100,
    'x-': 200,
    'x.': 300,
    'vnd.': 400,
    default: 900
};
// Score mime source (Logic originally from `jshttp/mime-types` module)
var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30 // definitions added by `jshttp/mime-db` project?
};
var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
};
/**
 * Get each component of the score for a mime type.  The sum of these is the
 * total score.  The higher the score, the more "official" the type.
 */ module.exports = function mimeScore(mimeType, source = 'default') {
    if (mimeType === 'application/octet-stream') {
        return 0;
    }
    const [type, subtype] = mimeType.split('/');
    const facet = subtype.replace(/(\.|x-).*/, '$1');
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    // All else being equal prefer shorter types
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
};
}),
"[project]/node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/.pnpm/mime-db@1.54.0/node_modules/mime-db/index.js [app-route] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
var mimeScore = __turbopack_context__.r("[project]/node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/mimeScore.js [app-route] (ecmascript)");
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
exports._extensionConflicts = [];
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().slice(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            types[extension] = _preferredType(extension, types[extension], type);
            // DELETE (eventually): Capture extension->type maps that change as a
            // result of switching to mime-score.  This is just to help make reviewing
            // PR #119 easier, and can be removed once that PR is approved.
            const legacyType = _preferredTypeLegacy(extension, types[extension], type);
            if (legacyType !== types[extension]) {
                exports._extensionConflicts.push([
                    extension,
                    legacyType,
                    types[extension]
                ]);
            }
        }
    });
}
// Resolve type conflict using mime-score
function _preferredType(ext, type0, type1) {
    var score0 = type0 ? mimeScore(type0, db[type0].source) : 0;
    var score1 = type1 ? mimeScore(type1, db[type1].source) : 0;
    return score0 > score1 ? type0 : type1;
}
// Resolve type conflict using pre-mime-score logic
function _preferredTypeLegacy(ext, type0, type1) {
    var SOURCE_RANK = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
    var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
    if (exports.types[extension] !== 'application/octet-stream' && (score0 > score1 || score0 === score1 && exports.types[extension]?.slice(0, 12) === 'application/')) {
        return type0;
    }
    return score0 > score1 ? type0 : type1;
}
}),
"[project]/node_modules/.pnpm/media-typer@1.1.0/node_modules/media-typer/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */ var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
/**
 * Module exports.
 */ exports.format = format;
exports.parse = parse;
exports.test = test;
/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */ function format(obj) {
    if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required');
    }
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !TYPE_NAME_REGEXP.test(type)) {
        throw new TypeError('invalid type');
    }
    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
        throw new TypeError('invalid subtype');
    }
    // format as type/subtype
    var string = type + '/' + subtype;
    // append +suffix
    if (suffix) {
        if (!TYPE_NAME_REGEXP.test(suffix)) {
            throw new TypeError('invalid suffix');
        }
        string += '+' + suffix;
    }
    return string;
}
/**
 * Test media type.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function test(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    return TYPE_REGEXP.test(string.toLowerCase());
}
/**
 * Parse media type to object.
 *
 * @param {string} string
 * @return {object}
 * @public
 */ function parse(string) {
    if (!string) {
        throw new TypeError('argument string is required');
    }
    if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string');
    }
    var match = TYPE_REGEXP.exec(string.toLowerCase());
    if (!match) {
        throw new TypeError('invalid media type');
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
        suffix = subtype.substr(index + 1);
        subtype = subtype.substr(0, index);
    }
    return new MediaType(type, subtype, suffix);
}
/**
 * Class for MediaType object.
 * @public
 */ function MediaType(type, subtype, suffix) {
    this.type = type;
    this.subtype = subtype;
    this.suffix = suffix;
}
}),
"[project]/node_modules/.pnpm/type-is@2.0.1/node_modules/type-is/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var contentType = __turbopack_context__.r("[project]/node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js [app-route] (ecmascript)");
var mime = __turbopack_context__.r("[project]/node_modules/.pnpm/mime-types@3.0.1/node_modules/mime-types/index.js [app-route] (ecmascript)");
var typer = __turbopack_context__.r("[project]/node_modules/.pnpm/media-typer@1.1.0/node_modules/media-typer/index.js [app-route] (ecmascript)");
/**
 * Module exports.
 * @public
 */ module.exports = typeofrequest;
module.exports.is = typeis;
module.exports.hasBody = hasbody;
module.exports.normalize = normalize;
module.exports.match = mimeMatch;
/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */ function typeis(value, types_) {
    var i;
    var types = types_;
    // remove parameters and normalize
    var val = tryNormalizeType(value);
    // no type or invalid
    if (!val) {
        return false;
    }
    // support flattened arguments
    if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1);
        for(i = 0; i < types.length; i++){
            types[i] = arguments[i + 1];
        }
    }
    // no types, return the content type
    if (!types || !types.length) {
        return val;
    }
    var type;
    for(i = 0; i < types.length; i++){
        if (mimeMatch(normalize(type = types[i]), val)) {
            return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
        }
    }
    // no matches
    return false;
}
/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */ function hasbody(req) {
    return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
}
/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {Object} req
 * @param {(String|Array)} types...
 * @return {(String|false|null)}
 * @public
 */ function typeofrequest(req, types_) {
    // no body
    if (!hasbody(req)) return null;
    // support flattened arguments
    var types = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
    // request content type
    var value = req.headers['content-type'];
    return typeis(value, types);
}
/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @return {String|false|null}
 * @public
 */ function normalize(type) {
    if (typeof type !== 'string') {
        // invalid type
        return false;
    }
    switch(type){
        case 'urlencoded':
            return 'application/x-www-form-urlencoded';
        case 'multipart':
            return 'multipart/*';
    }
    if (type[0] === '+') {
        // "+json" -> "*/*+json" expando
        return '*/*' + type;
    }
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @public
 */ function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false) {
        return false;
    }
    // split types
    var actualParts = actual.split('/');
    var expectedParts = expected.split('/');
    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false;
    }
    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
        return false;
    }
    // validate suffix wildcard
    if (expectedParts[1].slice(0, 2) === '*+') {
        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
    }
    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
        return false;
    }
    return true;
}
/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */ function normalizeType(value) {
    // Parse the type
    var type = contentType.parse(value).type;
    return typer.test(type) ? type : null;
}
/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {(string|null)}
 * @private
 */ function tryNormalizeType(value) {
    try {
        return value ? normalizeType(value) : null;
    } catch (err) {
        return null;
    }
}
}),
"[project]/node_modules/.pnpm/lru-cache@11.2.2/node_modules/lru-cache/dist/esm/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @module LRUCache
 */ __turbopack_context__.s([
    "LRUCache",
    ()=>LRUCache
]);
const defaultPerf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;
const warned = new Set();
/* c8 ignore start */ const PROCESS = typeof process === 'object' && !!process ? process : {};
/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{
    typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */ if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor(){
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted) return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort){
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = ()=>{
        if (!printACPolyfillWarning) return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */ // This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
/* c8 ignore stop */ class ZeroArray extends Array {
    constructor(size){
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls) return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls){
        /* c8 ignore start */ if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */ this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    #perf;
    /**
     * {@link LRUCache.OptionsBase.perf}
     */ get perf() {
        return this.#perf;
    }
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */ ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */ ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */ ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */ updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */ updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */ allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */ noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */ noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */ maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */ sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */ noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */ noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */ allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */ allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */ ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */ static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head () {
                return c.#head;
            },
            get tail () {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),
            moveToTail: (index)=>c.#moveToTail(index),
            indexes: (options)=>c.#indexes(options),
            rindexes: (options)=>c.#rindexes(options),
            isStale: (index)=>c.#isStale(index)
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */ get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */ get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */ get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */ get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */ get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */ get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */ get onInsert() {
        return this.#onInsert;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */ get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options){
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
        if (perf !== undefined) {
            if (typeof perf?.now !== 'function') {
                throw new TypeError('perf option must have a now() method if specified');
            }
        }
        this.#perf = perf ?? defaultPerf;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined && typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof onInsert === 'function') {
            this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */ getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = this.#perf.now())=>{
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(()=>{
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
        };
        this.#updateItemAge = (index)=>{
            starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
        };
        this.#statusTTL = (status, index)=>{
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */ if (!ttl || !start) return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = ()=>{
            const n = this.#perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */ if (t.unref) {
                    t.unref();
                }
            /* c8 ignore stop */ }
            return n;
        };
        this.getRemainingTTL = (key)=>{
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = (index)=>{
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = ()=>{};
    #statusTTL = ()=>{};
    #setItemTTL = ()=>{};
    /* c8 ignore stop */ #isStale = ()=>false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index)=>{
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation)=>{
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                } else {
                    throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status)=>{
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while(this.#calculatedSize > maxSize){
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = (_i)=>{};
    #addItemSize = (_i, _s, _st)=>{};
    #requireSize = (_k, _v, size, sizeCalculation)=>{
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#tail; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                } else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for(let i = this.#head; true;){
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                } else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */ *entries() {
        for (const i of this.#indexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */ *rentries() {
        for (const i of this.#rindexes()){
            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield [
                    this.#keyList[i],
                    this.#valList[i]
                ];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */ *keys() {
        for (const i of this.#indexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */ *rkeys() {
        for (const i of this.#rindexes()){
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */ *values() {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */ *rvalues() {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */ [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */ find(fn, getOptions = {}) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */ forEach(fn, thisp = this) {
        for (const i of this.#indexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */ rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()){
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */ purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({
            allowStale: true
        })){
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */ info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined) return undefined;
        const v = this.#valList[i];
        /* c8 ignore start - this isn't tested for the info function,
         * but it's the same logic as found in other places. */ const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined) return undefined;
        /* c8 ignore end */ const entry = {
            value
        };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (this.#perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */ dump() {
        const arr = [];
        for (const i of this.#indexes({
            allowStale: true
        })){
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined || key === undefined) continue;
            const entry = {
                value
            };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = this.#perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([
                key,
                entry
            ]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */ load(arr) {
        this.clear();
        for (const [key, entry] of arr){
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = this.#perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */ set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = 'add';
            noUpdateTTL = false;
            if (this.#hasOnInsert) {
                this.#onInsert?.(v, k, 'add');
            }
        } else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                s,
                                k,
                                'set'
                            ]);
                        }
                    }
                } else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([
                            oldVal,
                            k,
                            'set'
                        ]);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = 'update';
            }
            if (this.#hasOnInsert) {
                this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace');
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */ pop() {
        try {
            while(this.#size){
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                } else if (val !== undefined) {
                    return val;
                }
            }
        } finally{
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while(task = dt?.shift()){
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([
                    v,
                    k,
                    'evict'
                ]);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        } else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */ has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            } else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        } else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */ peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined || !allowStale && this.#isStale(index)) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', ()=>ac.abort(signal.reason), {
            signal: ac.signal
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context
        };
        const cb = (v, updateCache = false)=>{
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort) options.status.fetchAbortIgnored = true;
                } else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            // if nothing else has been written there but we're set to update the
            // cache and ignore the abort, or if it's still pending on this specific
            // background request, then write it to the cache.
            const vl = this.#valList[index];
            if (vl === p || ignoreAbort && updateCache && vl === undefined) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching !== undefined) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    } else {
                        this.#delete(k, 'fetch');
                    }
                } else {
                    if (options.status) options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er)=>{
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er)=>{
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                } else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej)=>{
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then((v)=>res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', ()=>{
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = (v)=>cb(v, true);
                    }
                }
            });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, {
                ...fetchOpts.options,
                status: undefined
            });
            index = this.#keyMap.get(k);
        } else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod) return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
        const { // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status) status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status) status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return p.__returned = p;
        } else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale) status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status) status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status) this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined) throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined) return v;
        const vv = memoMethod(k, v, {
            options,
            context
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */ get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status) status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale) status.returnedStale = true;
                    return allowStale ? value : undefined;
                } else {
                    if (status && allowStale && value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        } else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            } else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */ delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                } else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    } else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([
                                v,
                                k,
                                reason
                            ]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    } else if (index === this.#head) {
                        this.#head = this.#next[index];
                    } else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */ clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({
            allowStale: true
        })){
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            } else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([
                        v,
                        k,
                        reason
                    ]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while(task = dt?.shift()){
                this.#disposeAfter?.(...task);
            }
        }
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@sindresorhus+fnv1a@3.1.0/node_modules/@sindresorhus/fnv1a/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// FNV_PRIMES and FNV_OFFSETS from
// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param
__turbopack_context__.s([
    "default",
    ()=>fnv1a
]);
const FNV_PRIMES = {
    32: 16_777_619n,
    64: 1_099_511_628_211n,
    128: 309_485_009_821_345_068_724_781_371n,
    256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,
    512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,
    1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n
};
const FNV_OFFSETS = {
    32: 2_166_136_261n,
    64: 14_695_981_039_346_656_037n,
    128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,
    256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,
    512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,
    1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n
};
const cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    // eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop
    for(let index = 0; index < uint8Array.length; index++){
        hash ^= BigInt(uint8Array[index]);
        hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
}
function fnv1aEncodeInto(string, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
        throw new Error('The `utf8Buffer` option must have a length greater than zero');
    }
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    let remaining = string;
    while(remaining.length > 0){
        const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
        remaining = remaining.slice(result.read);
        for(let index = 0; index < result.written; index++){
            hash ^= BigInt(utf8Buffer[index]);
            hash = BigInt.asUintN(size, hash * fnvPrime);
        }
    }
    return hash;
}
function fnv1a(value, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES[size]) {
        throw new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');
    }
    if (typeof value === 'string') {
        if (utf8Buffer) {
            return fnv1aEncodeInto(value, size, utf8Buffer);
        }
        value = cachedEncoder.encode(value);
    }
    return fnv1aUint8Array(value, size);
}
}),
"[project]/node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "urlAlphabet",
    ()=>urlAlphabet
]);
const urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
}),
"[project]/node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "customAlphabet",
    ()=>customAlphabet,
    "customRandom",
    ()=>customRandom,
    "nanoid",
    ()=>nanoid,
    "random",
    ()=>random
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$nanoid$40$5$2e$1$2e$6$2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js [app-route] (ecmascript)");
;
;
;
const POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset;
function fillPool(bytes) {
    if (!pool || pool.length < bytes) {
        pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["webcrypto"].getRandomValues(pool);
        poolOffset = 0;
    } else if (poolOffset + bytes > pool.length) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["webcrypto"].getRandomValues(pool);
        poolOffset = 0;
    }
    poolOffset += bytes;
}
function random(bytes) {
    fillPool(bytes |= 0);
    return pool.subarray(poolOffset - bytes, poolOffset);
}
function customRandom(alphabet, defaultSize, getRandom) {
    let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
    let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize)=>{
        if (!size) return '';
        let id = '';
        while(true){
            let bytes = getRandom(step);
            let i = step;
            while(i--){
                id += alphabet[bytes[i] & mask] || '';
                if (id.length >= size) return id;
            }
        }
    };
}
function customAlphabet(alphabet, size = 21) {
    return customRandom(alphabet, size, random);
}
function nanoid(size = 21) {
    fillPool(size |= 0);
    let id = '';
    for(let i = poolOffset - size; i < poolOffset; i++){
        id += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$nanoid$40$5$2e$1$2e$6$2f$node_modules$2f$nanoid$2f$url$2d$alphabet$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["urlAlphabet"][pool[i] & 63];
    }
    return id;
}
}),
];

//# sourceMappingURL=node_modules__pnpm_2d756434._.js.map