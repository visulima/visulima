import { promises as fs } from "node:fs";
import { join } from "node:path";

import Semaphore from "./semaphore.js";

/**
 * DisposableEmailSyncManager - A manager for downloading and synchronizing
 * disposable email domains from multiple sources with detailed statistics and deduplication.
 */
class DisposableEmailSyncManager {
    constructor(options = {}) {
        this.domains = new Map();
        this.previousDomains = new Set();
        this.syncOptions = {
            concurrency: options.concurrency ?? 5,
            outputPath: options.outputPath ?? "dist",
            retries: options.retries ?? 3,
            timeout: options.timeout ?? 30_000,
        };
    }

    /**
     * Adds a domain to the collection with source tracking.
     * @param {string} domain The domain to add.
     * @param {string} source The source repository URL.
     */
    addDomain(domain, source) {
        const normalizedDomain = domain.toLowerCase().trim();
        const now = new Date().toISOString();

        if (this.domains.has(normalizedDomain)) {
            const entry = this.domains.get(normalizedDomain);

            entry.sources.add(source);
            entry.lastSeen = now;
        } else {
            this.domains.set(normalizedDomain, {
                domain: normalizedDomain,
                firstSeen: now,
                lastSeen: now,
                sources: new Set([source]),
            });
        }
    }

    /**
     * Builds detailed markdown report.
     * @param {object} stats Statistics object.
     * @returns {string} Markdown report content.
     */
    // eslint-disable-next-line class-methods-use-this -- Method uses stats parameter, not instance state
    buildDetailedReport(stats) {
        const successRate = ((stats.successfulDownloads / stats.totalRepositories) * 100).toFixed(1);

        return `# Disposable Email Domains Sync Report

## Summary

- **Last Sync**: ${stats.lastSyncTimestamp}
- **Processing Time**: ${(stats.processingTime / 1000).toFixed(2)}s
- **Total Repositories**: ${stats.totalRepositories}
- **Successful Downloads**: ${stats.successfulDownloads}
- **Failed Downloads**: ${stats.failedDownloads}
- **Success Rate**: ${successRate}%

## Domain Statistics

- **Total Unique Domains**: ${stats.uniqueDomains.toLocaleString()}
- **New Domains**: ${stats.newDomains.toLocaleString()}
- **Removed Domains**: ${stats.removedDomains.toLocaleString()}
- **Duplicate Entries Found**: ${stats.duplicates.toLocaleString()}

## Repository Details

${[...stats.repositoryStats.values()]
    .map(
        (repo) => `
### ${repo.url}

- **Status**: ${repo.success ? "✅ Success" : "❌ Failed"}
- **Domains**: ${repo.domainsCount.toLocaleString()}
- **Download Time**: ${repo.downloadTime}ms
- **File Size**: ${repo.fileSize.toLocaleString()} bytes

${repo.error ? `- **Error**: ${repo.error}` : ""}
`,
    )
    .join("\n")}

---

*Generated by DisposableEmailSyncManager*
`;
    }

    /**
     * Calculates final statistics after processing.
     * @param {object} stats Statistics object to update.
     * @param {number} startTime Start time timestamp.
     */
    calculateFinalStats(stats, startTime) {
        const currentDomains = new Set(this.domains.keys());
        const duplicates = [...this.domains.values()].reduce((sum, entry) => sum + (entry.sources.size - 1), 0);
        const newDomains = [...currentDomains].filter((domain) => !this.previousDomains.has(domain)).length;
        const removedDomains = [...this.previousDomains].filter((domain) => !currentDomains.has(domain)).length;
        const processingTime = Date.now() - startTime;
        const lastSyncTimestamp = new Date().toISOString();

        Object.assign(stats, {
            duplicates,
            lastSyncTimestamp,
            newDomains,
            processingTime,
            removedDomains,
            totalDomains: this.domains.size,
            uniqueDomains: this.domains.size,
        });
    }

    /**
     * Converts GitHub repository URL to raw file URL.
     * @param {string} repoUrl The GitHub repository URL.
     * @param {string} filePath The file path within the repository.
     * @returns {string} The raw GitHub file URL.
     */
    // eslint-disable-next-line class-methods-use-this -- Utility method, doesn't need instance state
    convertToRawGitHubUrl(repoUrl, filePath) {
        const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);

        if (!match) {
            throw new Error(`Invalid GitHub URL: ${repoUrl}`);
        }

        const owner = match[1];
        const repo = match[2];
        let cleanFilePath = filePath.startsWith("/") ? filePath.slice(1) : filePath;

        // Handle /refs/heads/ prefix - convert to branch name
        // e.g., /refs/heads/main/file.txt -> main/file.txt
        if (cleanFilePath.startsWith("refs/heads/")) {
            cleanFilePath = cleanFilePath.replace(/^refs\/heads\//, "");
        }

        return `https://raw.githubusercontent.com/${owner}/${repo}/${cleanFilePath}`;
    }

    /**
     * Simple delay utility for retry backoff.
     * @param {number} ms Milliseconds to delay.
     * @returns {Promise<void>} Promise that resolves after the delay.
     */
    // eslint-disable-next-line class-methods-use-this -- Utility method, doesn't need instance state
    delay(ms) {
        return new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }

    /**
     * Downloads domains from all repositories with controlled concurrency.
     * @param {Array<object>} repositories Array of repository configurations.
     * @returns {Promise<Array<object>>} Array of download results.
     */
    async downloadFromRepositories(repositories) {
        const results = [];
        const semaphore = new Semaphore(this.syncOptions.concurrency);

        const downloadPromises = repositories.map(async (repo) => semaphore.acquire(async () => this.downloadFromRepository(repo)));

        const downloadResults = await Promise.allSettled(downloadPromises);

        downloadResults.forEach((result, index) => {
            if (result.status === "fulfilled") {
                results.push(result.value);
            } else {
                results.push({
                    domainsCount: 0,
                    downloadTime: 0,
                    error: result.reason?.message ?? "Unknown error",
                    fileSize: 0,
                    success: false,
                    url: repositories[index].url,
                });
            }
        });

        return results;
    }

    /**
     * Downloads domains from a single repository with retry logic.
     * @param {object} repo Repository configuration.
     * @returns {Promise<object>} Download result object.
     */
    async downloadFromRepository(repo) {
        const startTime = Date.now();
        let lastError;

        const attempts = Array.from({ length: this.syncOptions.retries }, (_, i) => i);

        for (const attempt of attempts) {
            try {
                // eslint-disable-next-line no-await-in-loop -- Retry logic requires sequential attempts
                const domains = await this.fetchDomainsFromRepository(repo);
                const downloadTime = Date.now() - startTime;

                // Add domains to our collection
                domains.forEach((domain) => {
                    this.addDomain(domain, repo.url);
                });

                return {
                    domainsCount: domains.length,
                    downloadTime,
                    fileSize: domains.join("\n").length,
                    success: true,
                    url: repo.url,
                };
            } catch (error) {
                lastError = error;

                if (attempt < this.syncOptions.retries - 1) {
                    // eslint-disable-next-line no-await-in-loop -- Exponential backoff requires sequential delays
                    await this.delay(2 ** attempt * 1000);
                }
            }
        }

        return {
            domainsCount: 0,
            downloadTime: Date.now() - startTime,
            error: lastError?.message ?? "Unknown error",
            fileSize: 0,
            success: false,
            url: repo.url,
        };
    }

    /**
     * Extracts domain from various line formats.
     * @param {string} line The line to extract domain from.
     * @returns {string|undefined} Extracted domain or undefined.
     */
    // eslint-disable-next-line class-methods-use-this -- Utility method, doesn't need instance state
    extractDomain(line) {
        // Remove common prefixes and suffixes
        // Using safer regex patterns to avoid backtracking issues
        const cleanedLine = line
            .replace(/^(?:0\.0\.0\.0\s+|127\.0\.0\.1\s+|localhost\s+)/u, "") // Host file format
            .replace(/^\*\./u, "") // Wildcard format
            .replace(/\s\S*$/u, "") // Remove trailing content (safer pattern)
            .replace(/[,;][^,;]*$/u, "") // Remove trailing separators (safer pattern)
            .trim();

        // Extract email domain from email format
        const emailMatch = cleanedLine.match(/@([^\s@]+)$/u);

        if (emailMatch) {
            return emailMatch[1];
        }

        return cleanedLine || undefined;
    }

    /**
     * Fetches domains from a repository based on its type.
     * @param {object} repo Repository configuration.
     * @returns {Promise<Array<string>>} Array of domain strings.
     */
    async fetchDomainsFromRepository(repo) {
        switch (repo.type) {
            case "api": {
                return this.fetchFromApi(repo);
            }

            case "git": {
                return this.fetchFromGitRepository(repo);
            }

            case "raw": {
                return this.fetchFromRawUrl(repo);
            }

            default: {
                throw new Error(`Unsupported repository type: ${repo.type}`);
            }
        }
    }

    /**
     * Fetches domains from an API endpoint.
     * @param {object} repo Repository configuration.
     * @returns {Promise<Array<string>>} Array of domain strings.
     */
    async fetchFromApi(repo) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, this.syncOptions.timeout);

        try {
            const response = await fetch(repo.url, {
                headers: {
                    Accept: "application/json",
                    "User-Agent": "DisposableEmailSyncManager/1.0",
                },
                signal: controller.signal,
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            // Handle different API response formats
            if (Array.isArray(data)) {
                return data.filter((item) => typeof item === "string");
            }

            if (data.domains && Array.isArray(data.domains)) {
                return data.domains;
            }

            if (typeof data === "object") {
                return Object.keys(data);
            }

            throw new Error("Unsupported API response format");
        } finally {
            clearTimeout(timeoutId);
        }
    }

    /**
     * Fetches domains from GitHub repository using raw file URLs.
     * @param {object} repo Repository configuration.
     * @returns {Promise<Array<string>>} Array of domain strings.
     */
    async fetchFromGitRepository(repo) {
        const allDomains = [];
        const filePaths = repo.blocklist_files || [];

        const domainPromises = filePaths.map(async (filePath) => {
            const rawUrl = this.convertToRawGitHubUrl(repo.url, filePath);

            return this.fetchFromRawUrl({ ...repo, url: rawUrl });
        });

        const domainArrays = await Promise.all(domainPromises);

        for (const domains of domainArrays) {
            allDomains.push(...domains);
        }

        return allDomains;
    }

    /**
     * Fetches domains from a raw text URL.
     * @param {object} repo Repository configuration.
     * @returns {Promise<Array<string>>} Array of domain strings.
     */
    async fetchFromRawUrl(repo) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, this.syncOptions.timeout);

        try {
            const response = await fetch(repo.url, {
                headers: {
                    "User-Agent": "DisposableEmailSyncManager/1.0",
                },
                signal: controller.signal,
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const text = await response.text();

            return this.parseDomainList(text);
        } finally {
            clearTimeout(timeoutId);
        }
    }

    /**
     * Generates detailed human-readable report.
     * @param {object} stats Statistics object.
     * @returns {string} Report content as string.
     */
    generateDetailedReport(stats) {
        return this.buildDetailedReport(stats);
    }

    /**
     * Generates the main domains list file (JSON format only)
     */
    async generateDomainsList() {
        // Generate JSON format with metadata
        const domainsWithMetadata = [...this.domains.values()].map((entry) => {
            return {
                domain: entry.domain,
                firstSeen: entry.firstSeen,
                lastSeen: entry.lastSeen,
                sources: [...entry.sources],
            };
        });

        await fs.writeFile(join(this.syncOptions.outputPath, "domains.json"), JSON.stringify(domainsWithMetadata), "utf8");
    }

    /**
     * Generates all output files and statistics.
     */
    async generateOutputs() {
        await fs.mkdir(this.syncOptions.outputPath, { recursive: true });

        // Generate main domains list
        await this.generateDomainsList();
    }

    /**
     * Initializes statistics object.
     * @param {number} repositoryCount Number of repositories.
     * @returns {object} Initialized statistics object.
     */
    // eslint-disable-next-line class-methods-use-this -- Factory method, doesn't need instance state
    initializeStats(repositoryCount) {
        return {
            duplicates: 0,
            failedDownloads: 0,
            lastSyncTimestamp: "",
            newDomains: 0,
            processingTime: 0,
            removedDomains: 0,
            repositoryStats: new Map(),
            successfulDownloads: 0,
            totalDomains: 0,
            totalRepositories: repositoryCount,
            uniqueDomains: 0,
        };
    }

    /**
     * Validates domain format using regex.
     * @param {string} domain The domain to validate.
     * @returns {boolean} True if domain is valid.
     */
    // eslint-disable-next-line class-methods-use-this -- Utility method, doesn't need instance state
    isValidDomain(domain) {
        if (!domain || domain.length > 253) {
            return false;
        }

        // Simplified domain regex without unused capturing groups
        const domainRegex = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;

        return domainRegex.test(domain) && !domain.includes("..") && domain.includes(".");
    }

    /**
     * Loads previous domain list for comparison
     */
    async loadPreviousDomains() {
        try {
            const filePath = join(this.syncOptions.outputPath, "domains.json");
            const content = await fs.readFile(filePath, "utf8");
            const domainsData = JSON.parse(content);

            domainsData.forEach((entry) => {
                if (entry.domain) {
                    this.previousDomains.add(entry.domain.trim().toLowerCase());
                }
            });
        } catch {
            // File doesn't exist, which is fine for first run
        }
    }

    /**
     * Parses domain list from text content with various formats support.
     * @param {string} text The text content to parse.
     * @returns {Array<string>} Array of valid domain strings.
     */
    parseDomainList(text) {
        const domains = [];
        const lines = text.split("\n");

        for (const originalLine of lines) {
            const trimmedLine = originalLine.trim();

            // Skip empty lines and comments
            if (!trimmedLine || trimmedLine.startsWith("#") || trimmedLine.startsWith("//") || trimmedLine.startsWith(";")) {
                continue;
            }

            // Extract domain from various formats
            const domain = this.extractDomain(trimmedLine);

            if (domain && this.isValidDomain(domain)) {
                domains.push(domain.toLowerCase());
            }
        }

        return domains;
    }

    /**
     * Processes download results and updates statistics.
     * @param {Array<object>} results Array of download results.
     * @param {object} stats Statistics object to update.
     */
    // eslint-disable-next-line class-methods-use-this -- Method processes results, doesn't need instance state
    processDownloadResults(results, stats) {
        const statsCopy = { ...stats };

        results.forEach((result) => {
            statsCopy.repositoryStats.set(result.url, result);

            if (result.success) {
                statsCopy.successfulDownloads += 1;
            } else {
                statsCopy.failedDownloads += 1;
            }
        });

        Object.assign(stats, statsCopy);
    }

    /**
     * Main synchronization method that orchestrates the entire process.
     * @param {Array<object>} repositories Array of repository configurations.
     * @returns {Promise<object>} Sync result with domains, errors, and stats.
     */
    async sync(repositories) {
        const startTime = Date.now();
        const stats = this.initializeStats(repositories.length);
        const errors = [];

        try {
            // Load previous domains for comparison
            await this.loadPreviousDomains();

            // Download from all repositories with concurrency control
            const downloadResults = await this.downloadFromRepositories(repositories);

            // Process results and update stats
            this.processDownloadResults(downloadResults, stats);

            // Calculate final statistics
            this.calculateFinalStats(stats, startTime);

            // Generate outputs
            await this.generateOutputs();

            return {
                domains: new Set(this.domains.keys()),
                errors,
                stats,
            };
        } catch (error) {
            errors.push(error);

            throw error;
        }
    }
}

export default DisposableEmailSyncManager;
